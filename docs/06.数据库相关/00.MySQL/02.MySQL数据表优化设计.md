---
title: 02.MySQL数据表优化设计
date: 2022-04-06 22:36:34
permalink: /mysql/mysql02/
categories: 
  - MySQL
tags: 
  - MySQL
---

## 1 选择合适的数据类型

[MySQL 数据表优化设计（一）：选择合适的数据类型](https://juejin.cn/post/6966603936270647332)

> MySQL支持大量的数据类型，选择正确的类型对性能十分关键。本篇介绍了MySQL 的数据类型选择原则，可以根据这些基本的原则确定数据表字段的具体数据类型。

### 1.1 小而美

通常来说，尽可能使用占用存储空间小的数据类型来存储数据。这类数据类型通常也会更快，并且占用的磁盘空间、内存乃至缓存都更小，而且占用的 CPU 处理周期也少。

但是，务必准确估计要存储的数据值的范围。因为在数据表结构的多个地方扩充数据范围会是一个痛苦且耗时的过程。如果在犹豫哪种数据类型合适，那就选择你认为不会超出范围的最小空间的类型（在系统早期或者数据表     数据不多的情况下也可以进行调整）。

### 1.2 简单至上

数据类型越简单意味着处理数据的 CPU 周期越少。例如，整型相比字符型而言，处理起来更容易，这是因为字符集和比对使得字符的比较更复杂。举两个例子：应该使用 MySQL 内置的类型来存储时间和日期，而不是字符串。IP 地址也应该使用整型存储。

### 1.3 避免空值

很多数据表都是要可为空的列，虽然在应用中并不需要存储缺省值NULL。通常来说，指定列为 NOT NULL 会比存储 NULL 要更优。

MySQL 对于涉及到可为空的列优化起来更为困难，这是因为空值列使得索引、索引统计和值比较都变得复杂。而且，可为空的列占据的存储空间更大，且需要特殊的处理。如果在可为空的列上指定了索引，这会需要每个索引入口多一个额外的字节，甚至会导致 MyISAM 引擎固定大小的索引转换为可变大小的索引（例如对整数型字段做单列索引）。 不过，将 NULL 列转换为 NOT NULL列的性能改进通常并不大。因此，除非已经发现了 NULL 列对性能有很大的影响，否则不要优先去对已有的数据表结构进行改动。但是，如果需要对列构建索引，那应该尽量避免该列值可以为空，通常好的习惯是直接设置该列为 NOT NULL。

当然，也有例外，例如在 InnoDB 中仅仅使用了一个 bit 来存储 NULL 值，因此对大量数据存储来说可以有效节省空间，但是如果是 MyISAM 引擎就不是这样了。

### 1.4 选择数据类型的步骤

选择数据类型的第一步是决定数据列使用哪种常用的数据类型来表示，是数值型、字符串型还是时间类型。通常直接选择就挺不错的，但是在某些情况下会有特殊（比如金额、时间戳）。

第二步就是选择具体的类型。MySQL对于同一种数据类型会有多种存储方式，基于数据值范围、精度以及存储的物理空间，而还有些数据类型有一些特殊的属性。

例如，DATETIME 和 TIMESTAMP 都可以存储时间和日期，都可以精确到秒。然而，TIMESTAMP 类型只需要一半的存储空间，并且包括了时区信息，还支持自动更新。但另一方面，它存储的时间范围更小，它的这些特殊特性可能变成障碍。

再来看看基本数据类型。MySQL 支持数据类型的别名，例如 INTEGER，BOOL 和 NUMERIC。这些仅仅是别名，虽然看起来会让人困惑，但是实际上对性能没有影响。如果使用了别名数据类型创建数据表，可回忆使用 SHOW CREATE TABLE，可以看到实际上 MySQL 会转换为基础数据类型，而不是别名。

> 结语：MySQL 的数据表示方式很多，建议了解常用的数据类型的存储范围，占据的字节数，尽可能地根据产品预估数据值范围或长度，选择合适的数据类型，从而在创建表一开始就注重性能。后期再来调整的代价往往超出设计之初付出的细致思考的时间成本。

## 2 数值字段类型如何选择？

[MySQL 数据表优化设计（二）：数值字段类型如何选择?](https://juejin.cn/post/6967490332158066696)

> 在MySQL 中有两种数值类型，整型和实数（即带有小数的数字）。整型可以通过 TINYINT、SMALLINT、MEDIUMINT、INT 或 BIGINT 表示，分别对应8bit、16bit、24bit、32bit 和64bit 的存储空间。实数可以通过 FLOAT、DOUBLE 和 DECIMAL 表示，其中 FLOAT 和 DOUBLE 即通常所说的浮点数，由于计算机二进制存储的精度问题，其计算得到的是近似的结果。

### 2.1 整型字段类型设计

整型可以选择是否是无符号数，这样可以禁止使用负数，并且可以将存储的最大值翻倍，例如 TINYINT UNSIGNED类型的字段可以存储的值的范围是0-255，而不是有符号的-128-127。使用无符号还是有符号取决与字段类型的范围，但是如果确定字段是无符号的，那么优先选择无符号类型，因为最大值翻倍可以在一定程度上避免使用更大存储空间的整型类型。

MySQL 允许我们指定整型的宽度，例如 INT(11)。这对于大部分应用并没有太大意义——实际上 MySQL 并不会限制合法值的范围，也就是即便指定为 INT(11），实际上只要数值类型的存储空间足够，也可以存储超过设定宽度的整型，例如 INT(12)的数字也可能可以存储到 INT(11)类型的字段中。对于存储和计算而言，INT(1)和 INT(20)是等效的。

如果确实要考虑性能，应该是根据业务真实的数值范围来确定使用整型字段类型，原则是只要字段类型不会超过业务系统的数值最大值，那么尽可能地选择**低存储长度**的整型类型。如果是无符号的数值，那就尽量使用无符号属性。例如，假设使用整型替代枚举的话，如果枚举数量不超过255个，那就优先使用 UNSIGNED TINYINT 类型。

### 2.2 实数

实数不仅仅可以用来存储浮点数，实际上还可以使用 DECIMAL 类型来存储超出 BIGINT 类型的数值。对于 浮点数，MySQL 支持精确浮点数类型和不精确浮点数。

FLOAT 和 DOUBLE 类型支持标准数学运算的近似运算，浮点数的实际计算结果的精确度依赖于实现浮点数的平台。DECIMAL 类型用于存储精确的浮点数，在 MySQL 5.0以后，DECIMAL 也支持精确的数学运算（更早的版本实际上是使用浮点数来进行 DECIMAL 运算的）。但是，由于 CPU 本身不能直接精确计算浮点数，因此 DECIMAL 数据类型的计算速度会比浮点数要慢。

浮点数和 DECIMAL 都支持指定精度。DECIMAL 类型的可以分别指定小数点前后最大的数字位数，这会影响数据列的存储空间占用。MySQL5.0版本以后将数字位以二进制形式存储（每9位数使用4个字节存储）。例如 DECIMAL(18, 9)将在小数点两侧均为9位数字，算上小数点（占一个字节），总共需要9个字节来存储。DECIMAL 最大的数字位数是65（包含小数位和整数位），例如下面的表表创建语句会报错提示`#1426 - Too-big precision 66 specified for 'number'. Maximum is 65.`：

```sql
CREATE TABLE t_numbers ( 
  id INT(11) AUTO_INCREMENT PRIMARY KEY, 
  number DECIMAL(66,1) 
);
```

对于 FLOAT 和 DOUBLE类型，也可以类似 DECIMAL 那种方式指定整数位和小数位来确定存储范围和精度。不同的长度会使得 MySQL默认选择不同的数据类型并使用近似值存储数据。FLOAT 类型的存储长度固定为4个字节， DOUBLE 类型的存储长度固定为8个字节。精度是不确定的，指定精度对存储空间并没有帮助，因此从计算准确度考虑，建议是不要指定精度。在内部计算的时候，MySQL 会选择使用 DOUBLE类型计算 FLOAT 类型的数据。

由于 DECIMAL 占据的空间更大以及计算资源消耗也更大，因此建议只有在需要精确表示数值的情况下选择使用 DECIMAL（例如金融数据，如金额）。如果考虑计算性能，也可以考虑使用 BIGINT 来存储精确的浮点数，例如将金额统一乘以固定的倍数转换为 BIGINT 进行运算，这种方式的计算效率和存储空间都会更小。

## 3 CHAR 和 VARCHAR 要优先选择 VARCHAR 吗？

[MySQL 数据表优化设计（三）：CHAR 和 VARCHAR 要优先选择 VARCHAR 吗？](https://juejin.cn/post/6967874434665283591)

> MySQL 支持字符串的数据类型并不多，但是却有多种变化形式。MySQL 5.0以后更是支持每一列字符串可以有自己的字符集以及排序规则，这使得数据表设计更为复杂。本篇介绍字符类型的数据表字段 CHAR 和 VARCHAR 该如何选择。

### 3.1 VARCHAR 和 CHAR 类型

VARCHAR 和 CHAR 是两种主要的字符串类型，用于存储字符。不幸的是，由于实现的方式依赖于存储引擎，因此很难解释这些字符串在磁盘和内存中如何存储，除了除了常用的 InnoDB 和 MyISAM 外，假设你使用了其他存储引擎，应当仔细阅读存储引擎的文档。 

VARCHAR 存储可变长度的字符串，也是最常用的字符数据类型。相比固定长度的类型，VARCHAR 所需的存储空间更小，它会尽可能少地使用存储空间（例如，短的字符串占据的空间）。对于 MyISAM 来说，如果创建表的时候指定了 ROW_FORMAT=FIXED 的话，那么会使用固定的空间存储字段而导致空间浪费。VARCHAR 使用1-2个额外的字节存储字符串的长度：当最大长度低于255字节的时候使用1个字节，如果更多的话就使用2个字节。因此，拉丁字符集的 VARCHAR(10)会使用11个字节的存储空间，而 VARCHAR(1000)则会使用1002个字节的存储空间。 

VARCHAR 由于能够节省空间，因此可以改善性能。但是，由于长度可变，当更新数据表的时候数据行的存储空间会变化，这一定程度上会带来额外的开销。如果数据行的长度导致原有的存储位置无法存放，那么不同的存储引擎会做不同的处理。例如 MyISAM 可能产生数据行的碎片，而 InnoDB 需要进行磁盘分页来存放更新后的数据行。 

通常，如果最大的列长度远远高于平均长度的话（例如可选的备注字段），使用 VARCHAR 是划算的，同时如果更新的频次很低，那么碎片化也不会是一个问题。需要注意的是，如果使用的是 UTF-8字符集，则实际存储的字节长度是根据字符定的。对于中文，推荐的存储字符集是 utf8mb4。 

CHAR 类型的长度是固定的，MySQL 会对每个字段分配足够的存储空间。**存储CHAR 类型值的时候，MySQL 会移除后面多出来的空字符**。值是使用空字符进行对齐以便进行比较。对于短的字符串来说，使用 CHAR 更有优势，而如果所有的值的长度几乎一致的话，就可以使用 CHAR。例如存储用户密码的MD5值时使用 CHAR 就更合适，这是因为 MD5的长度总是固定的。同时，对于字段值经常改变的数据类型来说，CHAR 相比 VARCHAR 也更有优势，因为 CHAR 不会产生碎片。对于很短的数据列，使用 CHAR 比 VARCHAR更高效，例如使用CHAR(1)存储逻辑值的 Y 和 N，这种情况下只需要1个字节，而 VARCHAR 需要2个字节。 对于移除空字符这个特性会感觉奇怪，我们举个例子：

```sql
CREATE TABLE t_char_varchar_test (
  id INT PRIMARY KEY,
  char_col CHAR(10),
  varchar_col VARCHAR(10)
);

INSERT INTO t_char_varchar_test 
VALUES 
(1, 'string1', 'string1'),
(2, '  string2', '  string2'),
(3, 'string3  ', 'string3  ');
```

按上面的结果插入数据表后，string2中的前置空格不会移除，但使用 CHAR 类型存储时，string3尾随空格会被移除，使用 SQL 查询结果来检验一下：

```sql
SELECT CONCAT("'", char_col, "'"), CONCAT("'", varchar_col, "'") 
FROM t_char_varchar_test WHERE 1
```

得出来的结果如下，可以看到 CHAR 类型的 string3后面的空格被移除了，而 VARCHAR类型的没有。这种情况大多数时候不会有什么问题，实际在应用中也经常会使用 trim 函数移除两端的空字符，但是如果确实需要存储空格的时候，那就需要注意不要选择使用 CHAR 类型： 

数据如何存储是由存储引擎决定的，而且存储引擎处理固定长度和可变长度的数据的方式并不相同。Memory 引擎使用固定大小的行，因此它需要分配最大可能的存储空间——即便数据长度是可变的。但是，对于字符串的对齐和空字符截断是由 MySQL 服务端完成的，因此所有存储引擎都是一样的。 

与 CHAR 和 VARCHAR 相似的是 BINARY和 VARBINARY，用于存储二进制字节字符，BINARY 的对齐使用字符0的字节值来对齐，并且再获取值的时候不会截断。如果需要使用字符的字节值而不是字符的话，使用 BINARY 会更高效，这是因为比较时，一方面不需要考虑大小写，另一方面是MySQL一次只比较一个字节。 

> 结语：在实际数据表设计中，大多数情况下会选择使用 VARCHAR，但 VARCHAR 需要额外的1-2个字节存储字符串长度。需要注意的是在应用中最好能够限定字段的最大长度，从而可以使得数据表尽可能使用短的 VARCHAR来提高效率。同时，对于固定长度、长度很短或长度变化很小的字符类型，推荐使用 CHAR 类存储，以提高存储效率。

## 4 利用枚举节省存储空间

[MySQL数据表优化设计（四）：利用枚举节省存储空间](https://juejin.cn/post/6968444738009563143)

> 枚举在实际数据表使用中不太多，但是在某些场合却是可以发挥更好的性能，例如使用枚举替换有限的字符串值。需要注意的是枚举的存储结构有点特殊，本篇介绍枚举的应用场合及优势。

枚举在 MySQL 中的存储方式十分精简，依据枚举值的多少使用1-2个字节来存储。枚举在内部实际是使用整数代表列在对应枚举值的位置，然后在数据表中有一个后缀为.frm 的对照表文件存储枚举真实对应的值。以下面的表为例：

```sql
CREATE TABLE t_enum_test (
  gender ENUM('male', 'female', 'unknown') NOT NULL
);
INSERT INTO t_enum_test(gender) VALUES('male'), ('female'), ('unknown');
```

这个表的列实际是可以用于整数计算的，而且运算的结果是按整数返回的：

```sql
SELECT gender+0 FROM t_enum_test;
```

得出的结果实际是1，2，3。因此，如果你的枚举值是没有意义的数字的话，例如 ENUM('1', '2', '3')，那会导致很困惑，因此建议不要使用无意义的值或数字作为枚举。另外一个是，枚举的排序不是按枚举的字符串值来定的，而是基于其数字值。例如：

```sql
SELECT gender FROM t_enum_test ORDER BY gender DESC;
```

实际的次序并不是想象中的按字符串倒序的 unknown, male 和 female，而是 unknown, female 和 male。因此如果想要准确的排序，就需要指定按字段值排序：

```sql
SELECT gender FROM t_enum_test 
ORDER BY FIELD(gender, 'unknown', 'female', 'male') DESC;
```

这时候次序会按照指定的次序一次排列，可以使用 DESC 和 ASC 明确方向，但这个方向不是枚举值的排序，而是次序的变换。例如上面返回的结果是 male，female 和 unknown。因此，如果想要按次序使用枚举值排序，最好创建表的时候枚举值就是升序排列的。

枚举最大的缺陷是可选值是固定的，增加或减少枚举值都需要使用 ALTER TABLE 操作。因此，如果待选的字符串经常变化，那就不适用于枚举。当然，在 MySQL 5.1以后，往枚举结尾添加枚举值不会对重建整个表。同时，由于 MySQL 使用整型存储枚举，每次查询都需要转换为对应的字符串值，因此会带来一定的额外开销。这个开销通常受枚举值多少的影响。但是枚举值的优势也是显而易见的，使用枚举值的数据表列存储空间相比字符串更小。

在实际应用中，还有一种更为实际的做法，就是将枚举值当做整型存储到数据表中，然后在应用中实现类似 MySQL 的枚举查找表，通过这种方式可以减少 MySQL 内部的对照枚举的过程，性能上也更高，但是数据表的可读性会差一些。

## 5 如何选择一个合适的时间类型？

[MySQL 数据表优化设计（五）：如何选择一个合适的时间类型？](https://juejin.cn/post/6969155125025718279)

> MySQL 有多种类型存储日期和时间，例如 YEAR 和 DATE。MySQL 的时间类型存储的精确度能到秒（MariaDB 可以到毫秒级）。但是，也可以通过时间计算达到毫秒级。时间类型的选择没有最佳，而是取决于业务需要如何处理时间的存储。

MySQL 提供了 DATETIME 和 TIMESTAMP 两种非常相似的类型处理日期和时间，大部分情况下两种都是 OK 的，但是有些情况二者会互有优劣。

### 5.1 DATETIME

DATETIME 的时间跨度更大，可以从1001年到9999年，精度是秒。并且存储的格式是将日期和时间打包使用 YYYYMMDDhhmmss格式的整数存储，这个时间与时区无关，需要占用8个字节的存储空间。默认，MySQL 显示 的DATETIME是有序的，明确的格式，例如2021-06-02 18:35:23。这是 ANSI 的标准日期时间格式。

### 5.2 TIMESTAMP

TIMESTAMP即时间戳，存储的是自格林威治时间（GMT）1970年1月1日零点以来的秒数。和 Unix 系统的时间戳一样。TIMESTAMP 仅需要4个字节存储，因此能够表示的时间跨度更小，从1970年到2038年。MySQL 提供了 FROM_UNIXTIME 和 UNIX_TIMESTAMP 函数来完成时间戳和日期之间的转换。

在 MySQL 4.1版本后，TIMESTAMP 显示的格式和 DATETIME 类似，但是，TIMESTAMP 的显示依赖于时区。MySQL 的服务端、操作系统以及客户端连接都有时区的设置。因此，如果时间是从多个时区存储的话，那 TIMESTAMP 和 DATETIME 的差别就会很大。TIMESTAMP 会保留使用时的时区信息，而 DATETIME 仅仅是使用文本表示时间。

TIMESTAMP 还有额外的特性。默认地，MySQL会在没有指定值的情况下使用当前时间插入到 TIMESTAMP列，而更新的时候如果没有指定值会使用当前时间更新该字段，以下面的测试表为例：

```sql
CREATE TABLE t_time_test (
    id INT PRIMARY KEY,
    t_stamp TIMESTAMP,
    t_datetime DATETIME
);
```

可以看到MySQL 给的默认值就是当前时间戳 CURRENT_TIMESTAMP，并且有个 ON UPDATE CURRENT_TIMESTAMP表示会随之更新：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/308ceb1a60a041cbb0a3a28412e9df67~tplv-k3u1fbpfcp-zoom-1.image)

```sql
INSERT INTO t_time_test(id, t_datetime) VALUES
    (1, NULL), 
    (2, '2021-06-02 18:48:04'), 
    (3, NULL);
```

可以看到 t_stamp 列自动填充了当前时间。 

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11e09df881564996874d8a5a4b54a279~tplv-k3u1fbpfcp-zoom-1.image)

```sql
UPDATE `t_time_test` 
SET `t_datetime`='2021-06-02 19:00:00' WHERE id=1;
```

可以看到 id 为1的一列的 t_stamp 列会自动更新为当前时间。 

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c320f5b17694192857e5d2c269739fa~tplv-k3u1fbpfcp-zoom-1.image) 这个特性使得我们可以物协程序维护数据更新时间字段，而交由 MySQL 完成。

### 5.3 如何选择

从特性上看，可能会优先选择使用 TIMESTAMP 来存储时间，相比 DATETIME 来说更高效。也有些人使用整数存储 Unix 时间戳，实际上这种方式并不能获益，而且整数还需要额外进行处理，因此并不推荐这么做。但是一些情况需要注意不要使用 TIMESTAMP 存储时间：

- 生日：生日肯定会有早于1970年的，会超出 TIMESTAMP 的范围
- 有效期截止时间：TIMESTAMP 的最大时间是2038年，如果用来存类似身份证的有效期截止时间，营业执照的截止时间等就不合适。
- 业务生存时间：互联网时代讲究快，~~发展~~（死得）快。如果要成为长久存在的企业，那么你的业务时间很可能在2038年还在继续运营，毕竟现在都2021年了。如果你觉得公司业务挺不到2038年，那没关系。当然，如果幸运地挺到2038年，请务必写下一条待办事项：**到2038年1月1日前修改数据表时间戳字段类型**。

### 5.4 如何存储毫秒级时间

通常这个时候需要使用 BIGINT 来将时间转换为整型存储，或者是使用浮点数，用分数部分表示秒精度一下的时间，这两种方式都可行。当然，这个时候需要应用支持做格式转换。

### 5.5 结语

从安全稳妥的角度考虑，建议还是优先选择 DATETIME 类型，虽然相比 TIMESTAMP 会牺牲一点性能，但是 TIMESTAMP 的时间范围是硬伤，不要埋下一个隐患。

## 6 id 该如何选择数据类型？

[MySQL 数据表优化设计（六）：id 该如何选择数据类型？](https://juejin.cn/post/6969928505932906510)

> 为 id 列选择一个好的数据类型非常重要，id 列会经常用于做比较（例如联合查询的条件），以及用于查找其他列。而且，id 也经常用于外键。因此，id 列的数据类型不仅仅关系自身数据表，也关系到与之关联的其他数据表。因此，id 用何种数据类型就显得十分重要。

选择 id 的数据类型，不仅仅需要考虑数据存储类型，还需要了解 MySQL 对该种类型如何计算和比较。例如，MySQL 将 ENUM 和 SET 类型在内部使用整型存储，但是在字符串场景下会当做字符串进行比较。一旦选择了 id 的数据类型后，需要保证引用 id 的相关数据表的数据类型一致，而且是完全一致，这包括属性，例如长度、是否有符号！如果混用不同的数据类型可能导致性能问题，即便是没有性能问题，在进行比较时的隐式数据转换可能导致难以捉摸的错误。而如果在实际开发过程中忘记了数据类型不同这个问题，可能会突然出现意想不到的问题。

在选择长度的时候，也需要尽可能选择小的字段长度并给未来留有一定的增长空间。例如，如果是用于存放省份的话，我们只有几十个值，此时使用 TINYINT 就 INT 就更好，如果是相关的表也存有这个 id 的话，那么效率差别会很大。

下面是适用于 id 的一些典型的类型：

- 整型：整型通常来说是最佳的选择，这是因为整型的运算和比较都很快，而且还可以设置 AUTO_INCREMENT 属性自动递增。
- ENUM 和 SET：通常不会选择枚举和集合作为 id，然后对于那些包含有“类型”、“状态”、“性别”这类型的列来说是挺合适的。例如我们需要有一张表存储下拉菜单时，通常会有一个值和一个名称，这个时候值使用枚举作为主键也是可以的。
- 字符串：尽可能地避免使用字符串作为 id，一是字符串占据的空间更大，二是通常会比整型慢。选用字符串作为 id 时，还需要特别注意 MD5、SHA1和 UUID 这些函数。每个值是在很大范围的随机值，没有次序，这会导致插入和查询更慢：
  - 插入的时候，由于建立索引是随机位置（会导致分页、随机磁盘访问和聚集索引碎片），会降低插入速度。
  - 查询的时候，相邻的数据行在磁盘或内存上上可能跨度很大，也会导致速度更慢。

如果确实要使用 UUID 值，应当移除掉“-”字符，或者是使用 UNHEX 函数将其转换为16字节数字，并使用 BINARY(16)存储。然后可以使用 HEX 函数以十六进制的方式进行获取。UUID 产生的方法有很多，有些是随机分布的，有些是有序的，但是即便是有序的性能也不如整型。

### 6.1 分布式 id

对于单体应用来说，id 使用自增或者使用程序直接产生 id 问题都不大，但是如果是对于分布式应用来说，这种情况可能会导致主键冲突错误。对于分布式 id，目前有很多算法，例如有名的雪花（snowflakce）算法，以及国内大厂的一些分布式 id 开源算法，例如：

- 百度的[UidGenerator](https://github.com/baidu/uid-generator)。
- 美团的[Leaf](https://github.com/Meituan-Dianping/Leaf) 。

分布式 id 的基本原理是使用机器码、时间戳加序列号构成。通过一定的算法实现了分布式 id 的唯一性和有序性，具体有兴趣的可以看一下雪花算法的实现。

## 7 常见的数据表设计误区整理

[MySQL 数据表优化设计（七）：常见的数据表设计误区整理](https://juejin.cn/post/6970194546239995918)

> 虽然会有一些常规意义上的数据表错误设计和优秀设计原则，但是同样也会有 MySQL 特定的一些情况，这会导致我们犯一些 MySQL 特定的错误。本篇讨论常见的设计误区。

### 7.1 误区一：过多的数据列

MySQL 存储引擎的 API 是按照行缓冲区方式从服务端和存储引擎复制数据。服务端将缓冲区数据解码成数据列。然而，将行缓冲区的格式转换为数据行数据结构的列可能会代价很高。MyISAM 固定使用与服务端匹配的行格式，因此无需转换。然而，MyISAM 的可变行格式以及 InnoDB 的行格式总是需要进行转换。转换的代价依赖于列的数量。如果当数据表的列超过上百列的时候，会引起很高的 CPU 资源消耗——即便是使用到的列很少。曾经看过一篇文章，指的是一个多语言的解决方案，直接简单粗暴地将系统支持的语言用对应的列表示，例如：

```sql
CREATE TABLE t_multi_language_news (
  id INT PRIMARY KEY,
  title_cn VARCHAR(32),
  title_en VARCHAR(32),
  title_it VARCHAR(32),
  ...
  content_cn VARVHAR(256),
  content_en VARCHAR(256),
  conntent_it VARCHAR(256),
);
```

这种方式随着系统支持的语言越多，数据表的列越多，最终导致性能严重下降。如果你设计一个数据表的列数量超过100时，就需要考虑你的设计是否合理了。 **应对方式：**首先是考虑业务本身的设计是否合理，如果确实一个实体需要很多字段来描述，那么可以拆分数据表，通过扩展信息表来做。举个例子，对于资讯类的数据表，因为内容一般占据的空间会比较大，但是在列表不会直接查看，就可以拆成资讯主表和资讯详情表，主表存储标题、时间、摘要、缩略图附件 id 等列表要查看的信息即可。而资讯详情可以存储资讯的内容、来源、原文链接等信息。

### 7.2 误区二：过多的联合查询

MySQL 一次联合查询最多只能61张表。而有些设计主张不做冗余字段设计，这会导致复杂业务时需要连接多张表查询。即便是联合的表数量低于61个，也会引起性能的下降，而且整个 SQL 语句的维护将变得十分困难。作为一个设计的首要原则，就是如果想追求速度的话，一次查询不要跨太多的数据表做联合查询，尤其面临高并发场景的时候。 **应对方式：**首先，对于确定不会改变的字段，可以考虑冗余字段的方式减少联合查询。例如，一家企业的所属省份信息，就可以把省份代码、省份名称冗余了，而无需再通过省份代码去查询省份名称。其次，确实需要查其他表的情况下，可以考虑使用分步查询的方法，通过应用程序完成数据的组装，这种效率在数据表很多的时候会更高效，而且代码也更好维护。 **误区三：万能的枚举** 例如下面这种表设计：

```sql
CREATE TABLE t_countries (
  ...
  country ENUM('', '1', '2', ..., '45'),
  ...
);
```

这种方式本来可以通过一个以整数为 key的字典的查找表实现。如果是业务上增加了一个枚举，意味着整个表都需要使用 ALTER TABLE更新。而如果是使用应用代码的查找表，只需要增加新的键值对就好了。 **应对方式：**如果枚举确定不会变动（例如性别），那么没问题。如果枚举可能会增加，那么尽可能地通过应用程序来实现。

### 7.3 误区三：滥用 SET替代 ENUM

枚举ENUM 类型是数据表列的值只能是值集合中的一个，而 SET 类型是该列可以有一个或多个值。如果确定一个列只会有一个值，那么就应该优先使用枚举，而不是集合。例如下面的例子就是典型的滥用：

```sql
CREATE TABLE t_payment_way (
  ...
  is_default SET('Y', 'N') NOT NULL DEFAULT 'N',
  ...
);
```

很显然，is_default 要么是 Y，要么是 N，因此这里应该使用 ENUM。 **应对方式：**从业务层面考虑列的值是不是可能有多个，如果只有1个可选值那么就用 枚举ENUM。

### 7.4 误区四：生硬地避免NULL

很多文章都讨论过尽可能地避免使用 NULL，对于大部分场景这是一个好的设计，我们可以通过0，空字符串，约定的值等来表示空值。然而，不要因为这个而生硬套用，如果是这个值本身就是一个无意义的值的时候，那么使用 NULL 可能更合适。例如，如果要是有-1代表一个无意义的整数，可能会导致代码很复杂，甚至可能引起 bug。例如下面的例子：

```sql
CREATE TABLE t_person (
  birthday DATETIME NOT NULL DEFAULT '0000-00-00 00:00:00',
  ...,
);
```

将一个 DATETIME 类型的默认值设置为全部是0会很奇怪，假设我们要统计人员的年龄平均值的时候，会引起莫名其妙的问题，而这种场景使用 NULL 就不会纳入到统计中来。可以通过设置 MySQL 的 SQL_MODE 参数禁止使用无意义的日期，避免出现这种情况。 **应对方式：**设计表的时候可以尽量使用 NOT NULL 避免空值，但是不要过于生硬，对于有些字段使用默认值无法表名意义或与实际不符时，也是可以选择使用 NULL 列的。只是，需要注意索引列不要使用NULL。而实际上，绝大部分索引列不太可能会是 NULL。

### 7.5 误区五：使用整数替换时间戳

之前有讲到过时间格式如何选择的问题，实际上有些开发者会使用整数来存储时间戳，他们的理由是这样效率更高。从某种意义上来说，可能会提高一点效率，但是帮助不大，因为在 MySQL 内部DATETIME 和 TIMESTAMP 本身就是用整数存储的。而如果使用整数存储时间的话，意味着应用程序中需要做时间转换，或者是 SQL 语句要对指定的字段进行时间转换，带来的收益可能得不偿失。 **应对方式：**尽可能地使用 DATETIME 存储时间，如果需要存储秒级精度一下的时间，那么可以考虑使用 BIGINT 来存储。

### 7.6 误区六：忘记字段的最大存储范围

在实际中设计表的时候会忘记数据类型的存储范围，比如使用  TINYINT(2)并不是只能存储两位整数，实际TINYINT(2) 可以存储的范围是-128-127。 存储超过255的整数。这种错误在使用整数类型的时候很容易出现问题，在插入整数的时候，MySQL 不会检查实际的整数位数，而是按对应存储字节数的范围存入，这种情况假设不注意会存入无意义的值。例如下面的 INSERT 操作会成功，而我们可能误以为 TINYINT(2)只能存储2位整数：

```sql
CREATE TABLE t_int_test (
    id INT PRIMARY KEY,
    number TINYINT(2)
);

INSERT INTO t_int_test (id, number) VALUES (3,123);
```

**应对方式**：在应用程序中做数据校验。

> 结语：在实际设计数据表的过程中，除了需要考虑每个字段的数据类型之外，还需要考虑存储空间大小。对于常用的一些字段，如时间、标题、备注等，最好是内部形成一定的规范，大家遵照规范执行，并且增加校验能够避免很多问题。

## 8 范式和反范式数据库设计说的是啥？

[MySQL数据表优化设计（八）：范式和反范式数据库设计说的是啥?](https://juejin.cn/post/6971025986687074335)

> 在数据库设计规范中，范式和反范式经常被提到。了解范式的概念和原则对我们设计数据表很有帮助，然而，范式并不是完美的，在实际开发中，经常是依据范式设计，再根据实际业务情况加入反范式设计，形成混合模式。也就是实际上很少会有完全的范式设计或完全的反范式设计。

### 8.1 范式和反范式的区别

关于范式的概念，大家可以自行上网搜索，大部分情况下是讲前面的三大范式：

- 第一范式：每列都具有原子性，意即每一列的含义是不可再拆分的，不具备二义性。实际这个概念会依据也不同而不同，举个例子而言，姓名这个字段本身包含了姓和名，如果需要把二者当做不同的实体，那就需要拆分为两个字段；如果不需要那单独成一个字段也没问题。
- 第二范式：数据表每一列都都和主键相关。这意味着每个数据表不能保存多种实体数据，只保存与本实体相关的数据。这里的关键是是否需要冗余其他实体属性的字段。
- 第三范式：数据表每一列只和主键直接相关而不是间接相关。也就是数据表的列要与数据表主键代表实体的直接属性，而不是关联属性。

对于反范式而言，则允许信息冗余或者存放在多个不同的数据表。以经典的人员、部门和主管为例。最简单的设计是将三者直接放入同一张数据表（很多传统的 Excel 就是按这种方式记录数据）。

```sql
CREATE TABLE t_employees (
  employee VARCHAR(32),
  department VARCHAR(32),
  head VARCHAR(32)
);
```

这种方式一旦遇到数据修改时会出现不一致性。比如张三、李四和王五同在一个部门，张三的部门主管人员变了，需要同时更新李四和王五的数据。同时，部门必须依赖员工信息才存在，如果删除了一个部门的全部员工会导致部门信息也丢失。为避免这种问题，我们就需要建立两个实体表：

```sql
CREATE TABLE t_employees (
  employee VARCHAR(32),
  department VARCHAR(32)
);
CREATE TABLE t_department (
  department VARCHAR(32),
  head VARCHAR(32)
);
```

这样还只是满足第二范式，但是已经比之前的方式好多了。

### 8.2 范式设计的优缺点

通常在遇到性能问题的时候，会推荐使用范式设计，范式设计具有如下优点：

- 数据表更新相比反范式而言会更快。
- 由于没有冗余数据，因此需要更改的数据更少，单表存储空间也更小。
- 由于缺乏冗余数据，意味着使用 DISTINCT 和 GROUP BY 的查询的需求会更少，可以通过直接查询相关的主表完成这类操作。

范式表的缺点在于通常会需要至少一次的联表查询，甚至多张表联合查询。这种代价不但是高，还可能导致有些索引策略失效。

### 8.3 反范式设计的优缺点

反范式表最大的特点是同一张表包含了所有信息，因此避免了联合查询。如果不使用联合查询的话，大部分查询的最糟糕的情况是全表扫描（不使用索引的前提下）。即便是这样，也会比没有命中缓存的联合查询快，因为这样避免了随机 I/O 访问。 反范式表的单表索引策略会更有效。假设一个 UGC 的应用，其中部分用户是VIP用户。然后，如果想查看VIP用户的最近的10条信息，如果使用范式数据表，并且在发布日期上使用了索引，查询可能是下面的样子：

```sql
SELECT content, user_name
FROM user_content
    INNER JOIN user on user_content.user_id=user.id
WHERE user.account_level='vip'
ORDER BY user_content.published DESC LIMIT 10;
```

执行这个查询的时候，MySQL 需要在 published 索引上进行扫描，查找到的每一行还需要从用户表检查这个用户是否是 VIP 用户。如果只有少部分用户是 VIP 的话，那会非常低效。而如果使用反范式设计的话，可以将用户账户类型冗余到用户内容表中，并且添加联合索引（account_level, published），这样就无需使用联表查询了：

```sql
SELECT content, user_name
FROM user_content
WHERE account_level='vip'
ORDER BY published DESC LIMIT 10;
```

当然，反范式设计也会有其缺点，一是数据表冗余后会存储空间会变大，二是如果冗余列对应的主表发生了变更，可能需要进行大量的数据行更新。例如上面的例子，如果用户等级从 VIP降为了普通用户，那对应的用户内容表该用户的数据都需要同步更新（当然，也取决于业务是否要进行同步更新）。

### 8.4 实际开发应用

范式设计和反范式设计都有优点和缺点，那该如何选择呢？实际上，完全的范式设计和反范式设计只能是实验室的测试品，而无法在实际中应用。在实际开发中，通常是二者的混合使用，通常是部分范式数据表、缓存表或其他技术。 反范式数据设计最普遍的形式是冗余、缓存其他数据表的列。例如上面的用户内容表只冗余了用户账号等级，这避免了完全反范式的插入和删除时的同步问题。同时也使得用户内容表不至于过大，但是提升的效率很明显。但是，带来的副作用是更新用户的账号等级需要同时更新用户内容表，这个就取决于更新用户等级和查询的频率了。 另一个将数据冗余的场景是排序。例如，用户内容如果需要按作者姓名排序的话，按范式设计代价将十分高昂，而如果在用户内容表冗余作者姓名的话并加上索引，则会非常高效。 同样的，冗余一些附属表信息对主表查询也会很有帮助，例如假设我们想知道每个用户发表了多少条内容，就可以在用户表增设一个字段统计每个用户发布的内容条数，在用户每发布一条内容时更新该字段。这样如果需要查询用户的内容条数或者按用户内容条数排序时，就不需要每次都从用户内容表做一次 sum 操作了。

### 8.5 总结

范式和反范式数据库设计本身的理念是值得参考的，通过他们的理念我们可以更清楚地知道数据库该如何设计。在实际开发过程中，需要根据实际业务来决定主要遵循那种方式。这通常不是整个数据库遵循一个范式，而是在数据表层级上结合业务，融合二者的优缺点综合考虑。

## 9 如何设计统计数据表？

[MySQL 数据表优化设计（九）：如何设计统计数据表？](https://juejin.cn/post/6971763528445198372)

> 有些时候，改进数据表查询性能的最佳方式是在同一张数据表中冗余一些继承的数据。然而，有些时候需要新建完全独立的统计或缓存数据表，尤其是在需要反复查询的需求情况下。如果业务允许一些时间上的误差的话，那么这种方式会更好。

缓存型数据表通常在统计数据时会经常用到，因此也会叫统计性数据。举个例子来说，对于员工、部门数据表而言，我们可能会需要查询一个部门下有多少员工。这时候有三种方式实现：

- 在部门下增加一个员工数量的字段，每次对员工进行增、改、删操作时都需要同步更新员工数量（如果员工换部门，则需要更新多个部门的员工数量）。这种方式能够保证实时性，但是却很低效。对于如果是操作不频繁时是没问题的，假设相当频繁，就意味着每次都需要操作两张表，而且业务代码都需要做埋点处理，将统计业务和普通业务深度耦合在一起了。
- 每次查询的时候，从员工表中执行 SUM 函数，获取该部门的员工数。这种方式避免了埋点，但是每次都需要去员工数据表求和，如果员工数据量大的话会很低效。
- 新建一张统计表，每隔一定时间从员工表中汇总每个部门的人员数量。这种定时抽取数据的方式会牺牲一定的实时性，但降低了代码的耦合，由于部门不会太多，这张表的大小是可预测的，也提高了数据访问的效率。这种方式即**缓存型数据表**。

以掘金的手机端个人中心为例，为展示每个用户的关注人数、关注者和掘力值，不可能每次查询都去做一次 SUM，这意味着需要做多张表的 SUM 操作，效率会很低，而且掘力值的计算还涉及到更为复杂的计算方法（与文章的浏览量和点赞数有关）。因此，可以猜测一下大致的表设计，这样在查询用户个人主页信息的时候只需要从这一张表就可以读取到所有数据了。

```sql
CREATE t_user_summay (
  id INT PRIMARY KEY,
  user_id BIGINT(20),
  focused_user_cnt INT,
  followed_user_cnt INT,
  user_value INT,
  user_level ENUM('Lv1', 'Lv2', ..., 'Lv8'),
  created_time DATETIME,
  updated_time DATETIME,
);
```

### 9.1 是否需要实时更新

在实际应用过程中，统计表有两种方式，一种是实时更新，一种是周期性的重建数据。两种方式有利有弊，实时更新保证了查询数据的即时性，但是会牺牲性能，并且要求代码埋点，而且由于数据更新是没有规律的，可能产生碎片。周期性的重建数据牺牲了实时性，如果说大部分数据都不变的话会带来不必要的统计计算，但如果数据经常变动，那周期性地重建数据显然会更高效而且避免了埋点的情况。当然，避免应用程序的埋点也可以通过触发器来完成，可以参考[MySQL 高级特性（七）：触发器的正确打开方式](https://juejin.cn/post/6964737836339855374)。

### 9.2 物化视图工具（Flexviews）

在 MySQL 中，有一个 [Flexviews](https://github.com/greenlion/swanhart-tools/tree/master/flexviews) 的开源工具用于从数据库的binlog 中提取数据完成数据统计。有点类似与视图，但与视图所不同的是，Flexviews 产生的数据表是物理表，这也是为什么称之为物化视图的原因。而且，Flexviews 还支持增量更新和全量更新。推荐使用增量更新，以避免所有行的统计数据都需要重建的情况。增量更新会检查哪些数据行数据发生了改变，再执行更新操作，相比全量更新而言性能会更高。但为了检测数据改变，需要引入一个视图记录数据行的变化日志。

### 9.3 计数表

在实际开发中，我们经常会需要对一些操作进行计数，比如文章的阅读数、点赞数。如果将计数值放入同一张表很可能在更新的时候出现并发问题。使用独立的计数表可以避免查询缓存失效问题并使用一些更高级的技巧。例如统计文章的阅读数、点赞数的数据表：

```sql
CREATE TABLE t_article_counter (
  article_id INT PRIMARY KEY,
  read_cnt INT UNSIGNED NOT NULL,
  praise_cnt INT UNSIGNED NOT NULL
);
```

在更新阅读数的时候，可以使用 MySQL 的内置加1操作：

```sql
UPDATE t_article_counter 
SET read_cnt = read_cnt + 1
WHERE article_id = 1;
```

这种方式可以使得操作是单行的，对事物而言是互斥的，因此会将事务序列化处理避免并发问题。但是却会影响并发请求量。可以对文章增加多个插槽来提高并发量。

```sql
CREATE TABLE t_article_counter (
  id INT NOT NULL PRIMARY KEY,
  slot TINYINT UNSIGNED,
  article_id INT,
  read_cnt INT UNSIGNED NOT NULL,
  praise_cnt INT UNSIGNED NOT NULL,
  INDEX(article_id)
);
```

这时可以创建100个插槽初始化数据，在更新的时候可以这样操作：

```sql
UPDATE t_article_counter
SET read_cnt = read_cnt + 1 
WHERE slot = RAND() * 100 AND article_id = 1;
```

获取某篇文章的总阅读数时，需要使用一个 SUM 操作：

```sql
SELECT SUM(read_cnt) FROM t_article_counter
WHERE article_id = 1;
```

这种方式实际上是空间换时间，提高了并发量。

### 9.4 总结

本篇介绍了如何设计统计数据表，关键的核心在于业务类型。对于更新频率低、数据量小的表使用实时同步或者直接 SUM 求和问题都不大。而对于大数据表，高频率的更新的情况，则可以使用独立的统计表。同时，若存在高并发的情况，统计表中可以考虑每项主体增加多个插槽的方式提高并发量。如果是周期性地同步数据，也可以使用 Flexviews 物化视图插件实现。