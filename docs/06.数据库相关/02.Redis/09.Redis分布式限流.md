---
title: 09.Redis分布式限流
date: 2022-10-08 11:36:34
permalink: /redis/redis09/
categories: 
  - Redis
tags: 
  - Redis
---

## 1 分布式限流

所谓的分布式限流，其实道理很简单。分布式区别于单机限流的场景，它把整个分布式集群环境中所有服务器当做一个整体来考量。比如说针对IP限流，我们限制了1个IP每秒最多10个访问，不管来自这个IP地址的请求落在了哪台机器上，只要是访问了集群中的服务节点，那么都会受到限制规则的制约。

从上面的例子不难看出，我们必须将限流信息保存在一个“中心化”的组件上，这样它就可以获取到集群中所有机器的访问状态。

目前有两个比较主流的限流方案：

1. 网关层限流。将限流规则应用在所有流量的入口处
2. 中间件限流。将限流信息存储在分布式环境中某个中间件里（比如redis），每个组件都可以从这里获取到当前时间的流量统计，从而决定是否放行还是拒绝。

Lua脚本和 MySQL数据库的存储过程比较相似，他们执行一组命令，所有命令的执行要么全部成功或者失败，以此达到原子性。也可以把Lua脚本理解为，一段具有业务逻辑的代码块。

相比Redis事务，Lua脚本的优点：

- 减少网络开销：使用Lua脚本，无需向Redis 发送多次请求，执行一次即可，减少网络传输
- 原子操作：Redis 将整个Lua脚本作为一个命令执行，原子，无需担心并发
- 复用：Lua脚本一旦执行，会永久保存 Redis 中,，其他客户端可复用

Lua脚本大致逻辑如下：

```lua
-- 获取调用脚本时传入的第一个key值（用作限流的 key）
local key = KEYS[1]
-- 获取调用脚本时传入的第一个参数值（限流大小）
local limit = tonumber(ARGV[1])

-- 获取当前流量大小
local curentLimit = tonumber(redis.call('get', key) or "0")

-- 是否超出限流
if curentLimit + 1 > limit then
    -- 返回(拒绝)
    return 0
else
    -- 没有超出 value + 1
    redis.call("INCRBY", key, 1)
    -- 设置过期时间
    redis.call("EXPIRE", key, 2)
    -- 返回(放行)
    return 1
end
```

- 通过KEYS[1] 获取传入的key参数
- 通过ARGV[1]获取传入的limit参数
- redis.call方法，从缓存中get和key相关的值，如果为null那么就返回0
- 接着判断缓存中记录的数值是否会大于限制大小，如果超出表示该被限流，返回0
- 如果未超过，那么该key的缓存值+1，并设置过期时间为1秒钟以后，并返回缓存值+1

