---
title: Java并发系列
date: 2022-09-27 15:07:19
permalink: /pages/da09e9/
categories:
  - 架构设计
  - 高并发
tags:
  - 
---


## 1 并发编程

- [并发编程（一）—— volatile关键字和 atomic包](https://www.cmsblogs.com/article/1476741879)
- [并发编程（二）—— CountDownLatch、CyclicBarrier和Semaphore](https://www.cmsblogs.com/article/1483205597)
- [并发编程（三）—— ReentrantLock的用法](https://www.cmsblogs.com/article/4585930249)
- [并发编程（四）—— ThreadLocal源码分析及内存泄露预防](https://www.cmsblogs.com/article/7356492745)
- [并发编程（五）——AbstractQueuedSynchronizer 之 ReentrantLock源码分析](https://www.cmsblogs.com/article/1280548668)
- [并发编程（六）——AbstractQueuedSynchronizer 之 Condition 源码分析](https://www.cmsblogs.com/article/1548369157)
- [并发编程（七）——AbstractQueuedSynchronizer 之 CountDownLatch、CyclicBarrier、Semaphore 源码分析](https://www.cmsblogs.com/article/1785897206)
- [并发编程（八）—— Java 并发队列 BlockingQueue 实现之 ArrayBlockingQueue 源码分析](https://www.cmsblogs.com/article/1790513888)
- [并发编程（九）—— Java 并发队列 BlockingQueue 实现之 LinkedBlockingQueue 源码分析](https://www.cmsblogs.com/article/1813606741)
- [并发编程（十）—— Java 并发队列 BlockingQueue 实现之 SynchronousQueue源码分析](https://www.cmsblogs.com/article/1817300891)
- [并发编程（十一）—— Java 线程池 实现原理与源码深度解析（一）](https://www.cmsblogs.com/article/1847776063)
- [并发编程（十二）—— Java 线程池 实现原理与源码深度解析 之 submit 方法 （二）](https://www.cmsblogs.com/article/7376286786)
- [并发编程（十三）—— Java 线程池 实现原理与源码深度解析 之 Executors（三）](https://www.cmsblogs.com/article/7090033732)
- [并发编程（十四）—— ScheduledThreadPoolExecutor 实现原理与源码深度解析 之 DelayedWorkQueue](https://www.cmsblogs.com/article/1764366442)
- [并发编程（十五）——定时器 ScheduledThreadPoolExecutor 实现原理与源码深度解析](https://www.cmsblogs.com/article/1675707710)

## 2 Java 多线程教程

- [Java多线程（一）-----概念与原理](https://www.cmsblogs.com/article/1416630079458512896)
- [Java多线程（二）-----创建与启动](https://www.cmsblogs.com/article/1416630083711537152)
- [Java多线程（五）-----线程的同步与锁](https://www.cmsblogs.com/article/1416630087960367104)
- [Java多线程（六）-----线程的交互](https://www.cmsblogs.com/article/1416630092200808448)
- [Java多线程（七）-----线程的调度](https://www.cmsblogs.com/article/1416630096441249792)
- [java多线程（八）-----线程的同步](https://www.cmsblogs.com/article/1416630104947298304)
- [Java多线程（九）-----并发协作-生产者消费者模型](https://www.cmsblogs.com/article/1416630109204516864)
- [Java多线程（十一）-----有返回值的线程](https://www.cmsblogs.com/article/1416630113453346816)
- [Java多线程（十二）-----锁](https://www.cmsblogs.com/article/1416630117735731200)
- [Java多线程（十三）-----信号量](https://www.cmsblogs.com/article/1416630121980366848)
- [Java多线程（十四）-----阻塞队列](https://www.cmsblogs.com/article/1416630126216613888)
- [Java多线程（十五）-----阻塞栈](https://www.cmsblogs.com/article/1416630130452860928)
- [Java多线程（十六）-----条件变量](https://www.cmsblogs.com/article/1416630134689107968)

## 3 Java 并发容器源码分析

- [JAVA并发容器源码分析【一】开篇](https://www.cmsblogs.com/article/1423822604099260416)
- [JAVA并发容器源码分析【二】ConcurrentHashMap源码翻译之类注释与综述部分](https://www.cmsblogs.com/article/1416630393964204032)
- [JAVA并发容器源码分析【二】ConcurrentHashMap源码翻译之基础](https://www.cmsblogs.com/article/1416630398213033984)
- [JAVA并发容器源码分析【二】ConcurrentHashMap源码翻译之核心方法](https://www.cmsblogs.com/article/1416630402474446848)
- [JAVA并发容器源码分析【二】ConcurrentHashMap分析之CAS原理](https://www.cmsblogs.com/article/1416630406727471104)
- [JAVA并发容器源码分析【二】ConcurrentHashMap分析之数据结构(JDK7与JDK8)](https://www.cmsblogs.com/article/1416630410959523840)
- [JAVA并发容器源码分析【二】ConcurrentHashMap分析之tabAt-casTabAt-setTabAt](https://www.cmsblogs.com/article/1416630415199965184)
- [JAVA并发容器源码分析【二】ConcurrentHashMap分析之get](https://www.cmsblogs.com/article/1416630419427823616)
- [JAVA并发容器源码分析【二】ConcurrentHashMap分析之putVal](https://www.cmsblogs.com/article/1416630423664070656)
- [JAVA并发容器源码分析【二】ConcurrentHashMap分析之replaceNode](https://www.cmsblogs.com/article/1416630427900317696)
- [JAVA并发容器源码分析【二】ConcurrentHashMap分析之计数](https://www.cmsblogs.com/article/1416630432119787520)
- [JAVA并发容器源码分析【二】ConcurrentHashMap分析之初始化](https://www.cmsblogs.com/article/1416630436347645952)
- [JAVA并发容器源码分析【三】CopyOnWriteArrayList源码翻译](https://www.cmsblogs.com/article/1416630440588087296)
- [JAVA并发容器源码分析【三】CopyOnWriteArrayList源码分析](https://www.cmsblogs.com/article/1416630444845305856)
- [JAVA并发容器源码分析【四】LinkedBlockingQueue介绍](https://www.cmsblogs.com/article/1416630449077358592)
- [JAVA并发容器源码分析【四】LinkedBlockingQueue简单分析](https://www.cmsblogs.com/article/1416630453309411328)
- [JAVA并发容器源码分析【四】LinkedBlockingQueue的API源码分析](https://www.cmsblogs.com/article/1416630457562435584)
- [JAVA并发容器源码分析【四】LinkedBlockingQueue源码翻译](https://www.cmsblogs.com/article/1416630461807071232)

## 4 JMM

- [【JMM】线程通信机制之共享内存与消息传递](https://www.cmsblogs.com/article/1416630215848890368)
- [【JMM】内存模型之结构抽象](https://www.cmsblogs.com/article/1416630220080943104)
- [【JMM】内存模型之重排序](https://www.cmsblogs.com/article/1416630224321384448)
- [【JMM】内存模型之顺序一致性](https://www.cmsblogs.com/article/1416630228566020096)
- [【JMM】内存模型之多线程内存可见性-happens-before](https://www.cmsblogs.com/article/1416630232798072832)
- [【JMM】内存模型之内存屏障](https://www.cmsblogs.com/article/1416630237030125568)
- [【JMM】内存模型之伪共享(False Sharing)](https://www.cmsblogs.com/article/1416630241266372608)
- [【JMM】同步原语之Synchronized-简单介绍](https://www.cmsblogs.com/article/1416630245511008256)
- [【JMM】同步原语之volatile](https://www.cmsblogs.com/article/1416630249747255296)
- [【JMM】-同步原语之final重排序规则](https://www.cmsblogs.com/article/1416630253975113728)
- [【JMM】线程之简介与分类](https://www.cmsblogs.com/article/1416630258194583552)
- [【JMM】线程之状态（Windows+Linux+Java）](https://www.cmsblogs.com/article/1416630262443413504)
- [【JMM】Thread源码分析之创建和启动线程](https://www.cmsblogs.com/article/1416630266671271936)
- [【JMM】Thread源码分析之线程状态及常用方法](https://www.cmsblogs.com/article/1416630270911713280)
- [【JMM】Thread源码分析之线程中断](https://www.cmsblogs.com/article/1416630275147960320)

## 5 死磕 Java 并发

- [[死磕 Java 并发\] --- 死磕 Java 并发精品合集](https://www.cmsblogs.com/article/1391311158086078464)
- [[死磕 Java 并发\] --- 深入分析synchronized的实现原理](https://www.cmsblogs.com/article/1391297775492272128)
- [[死磕 Java 并发\] --- 深入分析volatile的实现原理](https://www.cmsblogs.com/article/1391297782668726272)
- [[死磕 Java 并发\] --- Java内存模型之happens-before](https://www.cmsblogs.com/article/1391297788905656320)
- [[死磕 Java 并发\] --- Java内存模型之重排序](https://www.cmsblogs.com/article/1391297793221595136)
- [[死磕 Java 并发\] --- Java内存模型之分析volatile](https://www.cmsblogs.com/article/1391297804252614656)
- [[死磕 Java 并发\] --- Java内存模型之从JMM角度分析DCL](https://www.cmsblogs.com/article/1391297811278073856)
- [[死磕 Java 并发\] --- J.U.C之AQS：AQS简介](https://www.cmsblogs.com/article/1391297814356692992)
- [[死磕 Java 并发\] --- J.U.C之AQS：CLH同步队列](https://www.cmsblogs.com/article/1391297829913366528)
- [[死磕 Java 并发\] --- J.U.C之AQS：同步状态的获取与释放](https://www.cmsblogs.com/article/1391297837127569408)
- [[死磕 Java 并发\] --- J.U.C之AQS：阻塞和唤醒线程](https://www.cmsblogs.com/article/1391297842710188032)
- [[死磕 Java 并发\] --- J.U.C之重入锁：ReentrantLock](https://www.cmsblogs.com/article/1391297847235842048)
- [[死磕 Java 并发\] --- J.U.C之读写锁：ReentrantReadWriteLock](https://www.cmsblogs.com/article/1391297853107867648)
- [[死磕 Java 并发\] --- J.U.C之Condition](https://www.cmsblogs.com/article/1391297860124938240)
- [[死磕 Java 并发\] --- 深入分析CAS](https://www.cmsblogs.com/article/1391297866286370816)
- [[死磕 Java 并发\] --- J.U.C之并发工具类：CyclicBarrier](https://www.cmsblogs.com/article/1391297871143374848)
- [[死磕 Java 并发\] --- J.U.C之并发工具类：CountDownLatch](https://www.cmsblogs.com/article/1391297877455802368)
- [[死磕 Java 并发\] --- J.U.C之并发工具类：Semaphore](https://www.cmsblogs.com/article/1391297883185221632)
- [[死磕 Java 并发\] --- J.U.C之并发工具类：Exchanger](https://www.cmsblogs.com/article/1391297888105140224)
- [[死磕 Java 并发\] --- J.U.C之Java并发容器：ConcurrentHashMap](https://www.cmsblogs.com/article/1391297896166592512)
- [[死磕 Java 并发\] --- J.U.C之ConcurrentHashMap红黑树转换分析](https://www.cmsblogs.com/article/1391297924817883136)
- [[死磕 Java 并发\] --- J.U.C之Java并发容器：ConcurrentLinkedQueue](https://www.cmsblogs.com/article/1391297934980681728)
- [[死磕 Java 并发\] --- J.U.C之Java并发容器：ConcurrentSkipListMap](https://www.cmsblogs.com/article/1391297944325591040)
- [[死磕 Java 并发\] --- J.U.C之阻塞队列：ArrayBlockingQueue](https://www.cmsblogs.com/article/1391297947458736128)
- [[死磕 Java 并发\] --- J.U.C之阻塞队列：PriorityBlockingQueue](https://www.cmsblogs.com/article/1391297961245413376)
- [[死磕 Java 并发\] --- J.U.C之阻塞队列：DelayQueue](https://www.cmsblogs.com/article/1391297966760923136)
- [[死磕 Java 并发\] --- J.U.C之阻塞队列：SynchronousQueue](https://www.cmsblogs.com/article/1391297982602809344)
- [[死磕 Java 并发\] --- J.U.C之阻塞队列：LinkedTransferQueue](https://www.cmsblogs.com/article/1391297987782774784)
- [[死磕 Java 并发\] --- J.U.C之阻塞队列：LinkedBlockingDeque](https://www.cmsblogs.com/article/1391297993491222528)
- [[死磕 Java 并发\] --- 深入分析ThreadLocal](https://www.cmsblogs.com/article/1391298010536873984)
- [[死磕 Java 并发\] --- J.U.C之线程池：ThreadPoolExecutor](https://www.cmsblogs.com/article/1391298033492299776)
- [[死磕 Java 并发\] --- J.U.C之线程池：ScheduledThreadPoolExecutor](https://www.cmsblogs.com/article/1391298038772928512)
- [[死磕 Java 并发\] --- J.U.C之线程池：线程池的基础架构](https://www.cmsblogs.com/article/1391310668996677632)
- [[死磕 Java 并发\] --- 分析 ArrayBlockingQueue 构造函数加锁问题](https://www.cmsblogs.com/article/1391310947527823360)
- [[死磕 Java 并发\] --- synchronized 的锁膨胀过程](https://www.cmsblogs.com/article/1391311068231503872)