---
title: 31.SpringBoot 集成 WebSocket，实现后台向前端推送信息
date: 2022-05-26 14:20:00
permalink: /SpringBoot/springboot31/
categories: 
  - SpringBoot
  - WebSocket
tags: 
  - WebSocket
---

- [上万字全面解读websocket(多种实现方案，含集群实现代码)_文艺青年学编程的博客-CSDN博客](https://blog.csdn.net/sinat_16658263/article/details/126693489)

## 1 什么是websocket？

WebSocket协议是基于TCP的一种新的网络协议。它实现了客户端与服务器全双工通信，既然是全双工，就说明了服务器可以主动发送信息给客户端。

![image-20220526142204529](https://www.lovebetterworld.com:8443/uploads/2022/05/26/628f1c3e1d3a1.png)

为什么不使用HTTP 协议呢？这是因为HTTP是单工通信，通信只能由客户端发起，客户端请求一下，服务器处理一下，这就太麻烦了。于是websocket应运而生。

![image-20220526142214527](https://www.lovebetterworld.com:8443/uploads/2022/05/26/628f1c47ab3f3.png)

### 1.1 Websocket使用场景

- 数字大屏实时更新，典型的如：航班信息，股票基金报价，体育实况等
- 消息提醒
- 社交订阅
- 多人聊天
- web页面日志实时查看
- web页面中模拟shell交互

## 2 SpringBoot真个和Websocket

- [【十六】springboot整合WebSocket（超详细）_小z♂的博客-CSDN博客_springboot websocket](https://blog.csdn.net/weixin_56995925/article/details/120543965)

### 2.1 导入依赖

```xml
<dependency>
     <groupId>org.springframework.boot</groupId>
     <artifactId>spring-boot-starter-websocket</artifactId>
</dependency>
```

### 2.2 编写WebSocketConfig配置类

```java
@Configuration
public class WebSocketConfig(){
    @Bean
    public ServerEndpointExporter serverEndpointExporter(){
        return new ServerEndpointExporter();
    }
}
```

### 2.3 编写WebSocket类

```java
//注册成组件
@Component
//定义websocket服务器端，它的功能主要是将目前的类定义成一个websocket服务器端。
//注解的值将被用于监听用户连接的终端访问URL地址
@ServerEndpoint("/websocket")
//如果不想每次都写private  final Logger logger = LoggerFactory.getLogger(当前类名.class); 
//可以用注解@Slf4j;可以直接调用log.info
@Slf4j
public class WebSocket {
 
    //实例一个session，这个session是websocket的session
    private Session session;
    //存放websocket的集合
    private static CopyOnWriteArraySet<WebSocket> webSocketSet = new CopyOnWriteArraySet<>();
 
    //前端请求时一个websocket时
    @OnOpen
    public void onOpen(Session session) {
        this.session = session;
        webSocketSet.add(this);
        log.info("【websocket消息】有新的连接, 总数:{}", webSocketSet.size());
    }
 
    //前端关闭时一个websocket时
    @OnClose
    public void onClose() {
        webSocketSet.remove(this);
        log.info("【websocket消息】连接断开, 总数:{}", webSocketSet.size());
    }
 
    //前端向后端发送消息
    @OnMessage
    public void onMessage(String message) {
        log.info("【websocket消息】收到客户端发来的消息:{}", message);
    }
 
    //新增一个方法用于主动向客户端发送消息
    public static void sendMessage(String message) {
        for (WebSocket webSocket: webSocketSet) {
            log.info("【websocket消息】广播消息, message={}", message);
            try {
                webSocket.session.getBasicRemote().sendText(message);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
    
    private void sendToUser(String message, String sendClientId, String myId) throws IOException {
        if (sendClientId == null || WsSessionManager.get(sendClientId) == null) {
            sendMessage(myId, "当前客户端不在线");
        } else {
            sendMessage(sendClientId, message);
        }
    }

    private void sendToAll(String message) throws IOException {
        for (String key : WsSessionManager.SESSION_POOL.keySet()) {
            WsSessionManager.get(key).getBasicRemote().sendText(message);
        }
    }
}
```

Session管理管理工具类：

```java
/**
 * Session管理管理工具类
 */
@Slf4j
public class WsSessionManager {

    /**
     * 保存连接 session 的地方
     */
    public static ConcurrentHashMap<String, Session> SESSION_POOL = new ConcurrentHashMap<>();

    /**
     * 添加 session
     *
     * @param key
     */
    public static void add(String key, Session session) {
        // 添加 session
        SESSION_POOL.put(key, session);
    }

    /**
     * 删除 session,会返回删除的 session
     *
     * @param key
     * @return
     */
    public static Session remove(String key) {
        // 删除 session
        return SESSION_POOL.remove(key);
    }

    /**
     * 删除并同步关闭连接
     *
     * @param key
     */
    public static void removeAndClose(String key) {
        Session session = remove(key);
        if (session != null) {
            try {
                // 关闭连接
                session.close();
            } catch (IOException e) {
                log.error("删除并同步关闭连接异常:{}", e.getMessage(), e);
            }
        }
    }

    /**
     * 获得 session
     *
     * @param key
     * @return
     */
    public static Session get(String key) {
        // 获得 session
        return SESSION_POOL.get(key);
    }
}
```

## 3 基于Netty实现WS

### 3.1 导入依赖

```xml
<dependency>
    <groupId>io.netty</groupId>
    <artifactId>netty-all</artifactId>
    <version>4.1.39.Final</version>
</dependency>
```

### 3.2 Netty配置

```java
@Component
@Slf4j
public class NettyServer {
    /**
     * 默认8090
     */
    private int port = 8090;
    private EventLoopGroup mainGroup;
    private EventLoopGroup subGroup;
    private ServerBootstrap server;
    private ChannelFuture future;


    public NettyServer() {
        mainGroup = new NioEventLoopGroup();
        subGroup = new NioEventLoopGroup();
        server = new ServerBootstrap();
        server.option(ChannelOption.SO_BACKLOG, 1024);
        server.group(mainGroup, subGroup).channel(NioServerSocketChannel.class).localAddress(this.port).childHandler(new ChannelInitializer<SocketChannel>() {
            @Override
            protected void initChannel(SocketChannel ch) throws Exception {
                System.out.println("收到新连接:" + ch.localAddress());
                ch.pipeline().addLast(new HttpServerCodec());
                ch.pipeline().addLast(new ChunkedWriteHandler());
                ch.pipeline().addLast(new HttpObjectAggregator(8192));
                ch.pipeline().addLast(new WebSocketServerProtocolHandler("/ws", "WebSocket", true, 65536 * 10));
                ch.pipeline().addLast(new MyWebSocketHandler());
            }
        });
    }

    public void start() {
        this.future = server.bind(this.port);
        log.info("netty server 启动完毕,启动端口为：" + this.port);
    }
}
```

### 3.3 处理器

```java
public class MyWebSocketHandler extends SimpleChannelInboundHandler<TextWebSocketFrame> {
    public static ChannelGroup channelGroup;
    static {
        channelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);
    }
    //客户端与服务器建立连接的时候触发，
    @Override
    public void channelActive(ChannelHandlerContext ctx) throws Exception {
        System.out.println("与客户端建立连接，通道开启！");
        //添加到channelGroup通道组
        channelGroup.add(ctx.channel());
    }
    //客户端与服务器关闭连接的时候触发，
    @Override
    public void channelInactive(ChannelHandlerContext ctx) throws Exception {
        System.out.println("与客户端断开连接，通道关闭！");
        channelGroup.remove(ctx.channel());
    }
    //服务器接受客户端的数据信息，
    @Override
    protected void channelRead0(ChannelHandlerContext ctx, TextWebSocketFrame msg){
        System.out.println("服务器收到的数据：" + msg.text());
        //sendMessage(ctx);
        sendAllMessage();
    }

    //给固定的人发消息
    private void sendMessage(ChannelHandlerContext ctx) {
        String message = "你好，"+ctx.channel().localAddress()+" 给固定的人发消息";
        ctx.channel().writeAndFlush(new TextWebSocketFrame(message));
    }

    //发送群消息,此时其他客户端也能收到群消息
    private void sendAllMessage(){
        String message = "我是服务器，这里发送的是群消息";
        channelGroup.writeAndFlush( new TextWebSocketFrame(message));
    }
}
```

### 3.4 启动类

```java
@SpringBootApplication
public class Main implements CommandLineRunner {
    @Autowired
    private NettyServer nettyServer;

    public static void main(String[] args) {
        SpringApplication.run(Main.class, args);
    }

    @Override
    public void run(String... args) throws Exception {
        this.nettyServer.start();
    }
}
```

