---
title: 42.SpringBoot多线程实现
date: 2022-09-14 10:20:00
permalink: /Java/springboot18/
categories: 
  - SpringBoot
tags: 
  - SpringBoot
---

## 一、配置启动类

在SpringBoot项目中，直接在启动类上加上@EnableAsync，然后在service层的方法上加上@Async，那么当controller调用该方法的时候，就会在主线程外自动新建线程执行该方法。

```java
@EnableAsync//开启异步任务支持
@SpringBootApplication
public class ThreadDemoApplication{
	public static void main(String[] args){
	SpringApplication.run(ThreadDemoApplication.class,args);
	}
}
```

在service中编写测试方法

```java
@Service
public class MutiThreadTest {
    @Async
    public void add() throws InterruptedException {
        for (int i=0;i<=100;i++){
            System.out.println(Thread.currentThread().getName()+":"+LocalDateTime.now().toLocalTime());
            Thread.sleep(1000);
        }
    }
}
```

如果没有自定义线程池@Async默认的线程池是SimpleAsyncTaskExecutor。

## 二、自定义线程池来使用@Async

1、新建一个线程池配置类，在配置类上加@EnableAsync，不用在启动类上加，可以配置不同的线程池，用bean的name做区分

```java
@Configuration //让spring扫描到
@EnableAsync
public class ThreadConfig {

    @Bean(name = "pool1")
    public Executor createExecutor(){
        ThreadPoolTaskExecutor threadPoolTaskExecutor = new ThreadPoolTaskExecutor();
        threadPoolTaskExecutor.setCorePoolSize(1);//核心线程数（默认线程数）
        threadPoolTaskExecutor.setMaxPoolSize(5);//最大线程数
        threadPoolTaskExecutor.setKeepAliveSeconds(60);//允许线程空闲时间（单位：默认为秒）
        threadPoolTaskExecutor.setQueueCapacity(200);//缓冲队列数
        threadPoolTaskExecutor.setThreadNamePrefix("Thread-0");//线程池名前缀
        //线程池对拒绝任务的处理策略
        threadPoolTaskExecutor.setRejectedExecutionHandler(new ThreadPoolExecutor.AbortPolicy());
        return threadPoolTaskExecutor;
    }

    @Bean(name = "pool2")
    public ThreadPoolTaskExecutor createExecutor2(){
        ThreadPoolTaskExecutor threadPoolTaskExecutor = new ThreadPoolTaskExecutor();
        threadPoolTaskExecutor.setCorePoolSize(1);//核心线程数（默认线程数）
        threadPoolTaskExecutor.setCorePoolSize(5);//最大线程数
        threadPoolTaskExecutor.setKeepAliveSeconds(60);//允许线程空闲时间(单位：默认为秒）
        threadPoolTaskExecutor.setQueueCapacity(200);//缓冲队列数
        threadPoolTaskExecutor.setThreadNamePrefix("Thread-1");//线程池名前缀
        //线程池对拒绝任务的处理策略
        threadPoolTaskExecutor.setRejectedExecutionHandler(new ThreadPoolExecutor.AbortPolicy());
        return threadPoolTaskExecutor;
    }
}
```

2、@Async的使用一样是在service层的方法上加，如果配置了多个线程池，可以用@Async("name")，那么表示线程池的@Bean的name，来指定用哪个线程池来处理。

假如只配置了一个线程池，直接用@Async就会用自定义的线程池执行。

加入配置了多个线程池，用@Async没有指定用哪个线程池，会默认的SimpleAsyncTaskExecutor来处理。

```java
@Component
public class MutiThreadTest1 {

    @Async("pool1")
    public void method1() throws InterruptedException {
        for (int i = 0;i<100;i++){
            System.out.println(Thread.currentThread().getName()+":"+ LocalDateTime.now().toLocalTime()+"====="+i);
        }
    }

    @Async("pool2")
    public void method2(){
        for (int i = 0;i<100;i++){            System.out.println(Thread.currentThread().getName()+":"+LocalDateTime.now().toLocalTime()+"----"+i);
        }
    }
}
```

如下方式会使@Async失效：

1. 异步方法使用static修饰
2. 异步类没有使用@Component注解（或其他注解）导致spring无法扫描到异步类
3. 异步方法不能与异步方法在同一个类中
4. 类中需要使用@Autowired或@Resource等注解自动注入，不能自己手动new对象
5. 如果使用SpringBoot框架必须在启动类中增加@EnableAsync注解
6. 在Async 方法上标注@Transactional是没用的。 在Async 方法调用的方法上标注@Transactional 有效。
7. 调用被@Async标记的方法的调用者不能和被调用的方法在同一类中不然不会起作用
8. 使用@Async时要求是不能有返回值的不然会报错的 因为异步要求是不关心结果的