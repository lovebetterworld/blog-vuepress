---
title: 32.SpringBoot整合jedis和redisson
date: 2022-09-14 13:20:00
permalink: /SpringBoot/springboot32/
categories: 
  - SpringBoot
tags: 
  - SpringBoot
---

- [【二十五】springboot整合jedis和redisson布隆过滤器处理缓存穿透_小z♂的博客-CSDN博客_jedis redisson](https://blog.csdn.net/weixin_56995925/article/details/126208394)

## 一、什么是缓存穿透

![99f5389066494258a7f470339466e942.png](https://img-blog.csdnimg.cn/99f5389066494258a7f470339466e942.png)

 为了解决数据库的压力问题，引入了缓存这一东西，将某些数据存入缓存后，接口直接从缓存取值，从而减轻数据库的压力。当客户端访问的数据在缓存中不存在时，就会到数据库查询，查到了再存入缓存，而缓存击穿就是恶意攻击，一直访问数据库中不存在的数据，导致直接穿过缓存，每次都击中数据库。

## 二、怎么解决缓存穿透

解决缓存穿透的方式可以通过**布隆过滤网和空值设置法**，本文会将两种方法都使用到。

### 2.1 布隆过滤器

介绍布隆过滤器之前，先介绍一下哈希函数，我们在Java中的HashMap，HashSet也接触过hashcode()这个函数。

> 哈希函数指将哈希表中元素的关键键值通过一定的函数关系映射为元素存储位置的函数。

哈希函数的特点：

- **如果根据同一个哈希函数得到的哈希值不同，那么这两个哈希值的原始输入值肯定不同**
- **如果根据同一个哈希函数得到的两个哈希值相等，两个哈希值的原始输入值有可能相等，有可能不相等**

说完哈希函数，那什么是布隆过滤器呢

> 布隆过滤器实际上是一个非常长的二进制向量(bitmap)和一系列随机哈希函数。

优点：

- 布隆过滤器存储空间和插入/查询时间都是常数
- Hash函数相互之间没有关系，方便由硬件并行实现
- 布隆过滤器不需要存储元素本身，在某些对保密要求非常严格的场合有优势
- 布隆过滤器可以表示全集，其它任何数据结构都不能

缺点：

- 有一定的误判率

> 常见的补救办法是建立一个小的白名单，存储那些可能被误判的元素。但是如果元素数量太少，使用散列表足矣。

- 一般情况下不能从布隆过滤器中删除元素。

> 我们很容易想到把位列阵变成整数数组，每插入一个元素相应的计数器加1， 这样删除元素时将计数器减掉就可以了。然而要保证安全的删除元素并非如此简单。首先我们必须保证删除的元素的确在布隆过滤器里面，这一点单凭这个过滤器是无法保证的。另外计数器回绕也会造成问题。



可以理解为就是一个普通的过滤器拦截器，将数据通过add方法存入过滤器之后，通过它提供的contains方法判断是否存在某个值，返回值也是true或者false。

他会有一定的误差（返回true，表示不一定存在；返回false，表示一定不存在），但是我认为解决缓存穿透可以不用考虑这个问题，因为只需要确认它一定不存在就可以了。

具体使用时，在项目启动时可以查询数据库，将所有需要缓存的数据存入过滤器，每次接口调用时，通过它先判断一遍，存在后再走后面的逻辑（查缓存、查数据库）。

![5db6bf13bc8c42c3913b2afdad225816.png](https://img-blog.csdnimg.cn/5db6bf13bc8c42c3913b2afdad225816.png)

#### 2.2.1 布隆过滤器的作用

布隆过滤器可以用于检索一个元素是否在一个集合中，常用于解决如下问题

- 解决Redis缓存穿透
- 邮件过滤，使用布隆过滤器来做邮件黑名单过滤
- 解决视频推荐过的不再推荐

#### 2.2.2 布隆过滤器的基本原理

- 首先，建立一个二进制向量，并将所有位设置为0。
- 然后，选定K个散列函数，用于对元素进行K次散列，计算向量的位下标。
- 添加元素：当添加一个元素到集合中时，通过K个散列函数分别作用于元素，生成K个值作为下标，并将向量的相应位设置为1。
- 检查元素：如果要检查一个元素是否存在集合中，用同样的散列方法，生成K个下标，并检查向量的相应位是否全部是1。如果全为1，则该元素很可能在集合中；否则（只要有1个或以上的位为0），该元素肯定不在集合中。

![在这里插入图片描述](https://img-blog.csdnimg.cn/16c4e0ef40c34788b22071f4319c705b.png)

### 2.2 空值设置法

查询数据库时，若不存在该数据，设置一个过期时间短的缓存到redis，下次到缓存查询时就能查到该值，并直接返回对应的value值null，设置一个较短的过期时间是为了以防后面该值被误处理，一直查询处于空值，还有就是可能会出现大量的处于null值的缓存，占用缓存资源。

![41922f54b11a46f4bbb08c286d7eb2a5.png](https://img-blog.csdnimg.cn/41922f54b11a46f4bbb08c286d7eb2a5.png)

 综上，本次demo的缓存穿透解决方式，如下（综合两种方式）：

![a18ad18a83e743da97941a45668831f2.png](https://img-blog.csdnimg.cn/a18ad18a83e743da97941a45668831f2.png)

------

## 三、SpringBoot整合Redis

通常有两种方式，一种是RedisTemplate，一种是Jedis。

> - RedisTemplate：RedisTemplate是SpringDataRedis中对JedisApi的高度封装。
> - Jedis：Jedis是Redis官方推荐的面向Java的操作Redis的客户端。

原生Jedis效率优于RedisTemplate。

## 四、Spring Boot中集成Redisson实现布隆过滤器

- [Spring Boot集成Redisson布隆过滤器解决redis缓存穿透问题_dreaming9420的博客-CSDN博客_springboot集成布隆过滤器](https://blog.csdn.net/dreaming9420/article/details/124153422)

![在这里插入图片描述](https://img-blog.csdnimg.cn/ba234a123024433faf0c17808a5463e6.png)

### 4.1 添加Maven依赖

```xml
<!--redisson-->
<dependency>
	<groupId>org.redisson</groupId>
	<artifactId>redisson-spring-boot-starter</artifactId>
	<version>3.17.0</version>
</dependency>
```

### 4.2 配置yml

```yaml
spring:
  datasource:
    username: xx
    password: xxxxxx
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/test?useUnicode=true&characterEncoding=utf-8&serverTimezone=CTT
  cache:
    type: redis
  redis:
    database: 0
    port: 6379               # Redis服务器连接端口
    host: localhost          # Redis服务器地址
    password: xxxxxx         # Redis服务器连接密码（默认为空）
    timeout: 5000            # 超时时间
```

### 4.3 配置RedissonConfig

```java
import com.fasterxml.jackson.annotation.JsonAutoDetect;
import com.fasterxml.jackson.annotation.PropertyAccessor;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.redisson.Redisson;
import org.redisson.api.RedissonClient;
import org.redisson.config.Config;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.cache.CacheManager;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.cache.RedisCacheConfiguration;
import org.springframework.data.redis.cache.RedisCacheManager;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.RedisSerializationContext;
import org.springframework.data.redis.serializer.RedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;

import java.time.Duration;
import java.util.Random;

@EnableCaching
@Configuration
public class RedissonConfig {

    @Value("${spring.redis.host}")
    private String host;

    @Value("${spring.redis.port}")
    private String port;

    @Value("${spring.redis.password}")
    private String password;


    @Bean(destroyMethod = "shutdown")  // bean销毁时关闭Redisson实例，但不关闭Redis服务
    public RedissonClient redisson() {
        //创建配置
        Config config = new Config();
        /**
         *  连接哨兵：config.useSentinelServers().setMasterName("myMaster").addSentinelAddress()
         *  连接集群： config.useClusterServers().addNodeAddress()
         */
        config.useSingleServer()
                .setAddress("redis://" + host + ":" + port)
                .setPassword(password)
                .setTimeout(5000);
        //根据config创建出RedissonClient实例
        return Redisson.create(config);
    }

    @Bean
    public CacheManager RedisCacheManager(RedisConnectionFactory factory) {
        RedisSerializer<String> redisSerializer = new StringRedisSerializer();
        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);
        // 解决查询缓存转换异常的问题
        ObjectMapper om = new ObjectMapper();
        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        /**
         * 新版本中om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL)已经被废弃
         * 建议替换为om.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, ObjectMapper.DefaultTyping.NON_FINAL)
         */
        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        jackson2JsonRedisSerializer.setObjectMapper(om);
        // 配置序列化解决乱码的问题
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
                // 设置缓存过期时间  为解决缓存雪崩,所以将过期时间加随机值
                .entryTtl(Duration.ofSeconds(60 * 60 + new Random().nextInt(60 * 10)))
                // 设置key的序列化方式
                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))
                // 设置value的序列化方式
                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer));
        // .disableCachingNullValues(); //为防止缓存击穿，所以允许缓存null值
        RedisCacheManager cacheManager = RedisCacheManager.builder(factory)
                .cacheDefaults(config)
                // 启用RedisCache以将缓存 put/evict 操作与正在进行的 Spring 管理的事务同步
                .transactionAware()
                .build();
        return cacheManager;
    }
}
```

### 4.4 工具类BloomFilterUtil

```java
import org.redisson.api.RBloomFilter;
import org.redisson.api.RedissonClient;
import org.springframework.stereotype.Component;

import javax.annotation.Resource;

@Component
public class BloomFilterUtil {

    @Resource
    private RedissonClient redissonClient;

    /**
     * 创建布隆过滤器
     *
     * @param filterName         过滤器名称
     * @param expectedInsertions 预测插入数量
     * @param falsePositiveRate  误判率
     */
    public <T> RBloomFilter<T> create(String filterName, long expectedInsertions, double falsePositiveRate) {
        RBloomFilter<T> bloomFilter = redissonClient.getBloomFilter(filterName);
        bloomFilter.tryInit(expectedInsertions, falsePositiveRate);
        return bloomFilter;
    }
}
```

### 4.5 编写service实现层

其它层正常编写即可，与之前并无差别，此处不再展示

```java
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.company.springboot.entity.User;
import com.company.springboot.mapper.UserMapper;
import com.company.springboot.service.UserService;
import com.company.springboot.util.BloomFilterUtil;
import org.redisson.api.RBloomFilter;
import org.redisson.api.RedissonClient;
import org.redisson.client.codec.StringCodec;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.CachePut;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Service;

import javax.annotation.PostConstruct;
import javax.annotation.Resource;
import java.util.List;
import java.util.Random;
import java.util.concurrent.TimeUnit;

@Service
public class UserServiceImpl extends ServiceImpl<UserMapper, User>
        implements UserService {
    // 预期插入数量
    static long expectedInsertions = 200L;
    // 误判率
    static double falseProbability = 0.01;
    // 非法请求所返回的JSON
    static String illegalJson = "[\"com.company.springboot.entity.User\",{\"id\":null,\"userName\":\"null\",\"sex\":null,\"age\":null}]";
    private RBloomFilter<Long> bloomFilter = null;
    @Resource
    private BloomFilterUtil bloomFilterUtil;
    @Resource
    private RedissonClient redissonClient;
    @Resource
    private UserMapper userMapper;
    
    @PostConstruct // 项目启动的时候执行该方法，也可以理解为在spring容器初始化的时候执行该方法
    public void init() {
        // 启动项目时初始化bloomFilter
        List<User> userList = this.list();
        bloomFilter = bloomFilterUtil.create("idWhiteList", expectedInsertions, falseProbability);
        for (User user : userList) {
            bloomFilter.add(user.getId());
        }
    }

    @Cacheable(cacheNames = "user", key = "#id", unless = "#result==null")
    public User findById(Long id) {
        // bloomFilter中不存在该key,为非法访问
        if (!bloomFilter.contains(id)) {
            System.out.println("所要查询的数据既不在缓存中，也不在数据库中，为非法key");
               /**
             * 设置unless = "#result==null"并在非法访问的时候返回null的目的是不将该次查询返回的null使用
             * RedissonConfig-->RedisCacheManager-->RedisCacheConfiguration-->entryTtl设置的过期时间存入缓存。
             *
             * 因为那段时间太长了，在那段时间内可能该非法key又添加到bloomFilter，比如之前不存在id为1234567的用户，
             * 在那段时间可能刚好id为1234567的用户完成注册，使该key成为合法key。
             *
             * 所以我们需要在缓存中添加一个可容忍的短期过期的null或者是其它自定义的值,使得短时间内直接读取缓存中的该值。
             *
             * 因为Spring Cache本身无法缓存null，因此选择设置为一个其中所有值均为null的JSON，
             */
            redissonClient.getBucket("user::" + id, new StringCodec()).set(illegalJson, new Random().nextInt(200) + 300, TimeUnit.SECONDS);
            return null;
        }
        // 不是非法访问，可以访问数据库
        System.out.println("数据库中得到数据*****");
        return userMapper.selectById(id);
    }

    // 先执行方法体中的代码，成功执行之后删除缓存
    @CacheEvict(cacheNames = "user", key = "#id")
    public boolean delete(Long id) {
        // 删除数据库中具有的数据,就算此key从此之后不再出现，也不能从布隆过滤器删除
        return userMapper.deleteById(id) == 1;
    }

    // 如果缓存中先前存在，则更新缓存;如果不存在，则将方法的返回值存入缓存
    @CachePut(cacheNames = "user", key = "#user.id")
    public User update(User user) {
        userMapper.updateById(user);
        // 新生成key的加入布隆过滤器，此key从此合法,因为该更新方法并不更新id,所以也不会产生新的合法的key
        bloomFilter.add(user.getId());
        return user;
    }

    @CachePut(cacheNames = "user", key = "#user.id")
    public User insert(User user) {
        userMapper.insert(user);
        // 新生成key的加入布隆过滤器，此key从此合法
        bloomFilter.add(user.getId());
        return user;
    }
}
```