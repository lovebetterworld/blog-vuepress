---
title: 41.Java实现多线程
date: 2022-09-14 10:21:00
permalink: /Java/threadpool41/
categories: 
  - Java
tags: 
  - Java
---

- [Java 实现多线程的四种方式 超详细_橘右今的博客-CSDN博客_java 实现多线程](https://blog.csdn.net/PassionAnytime/article/details/126143524)

> 实现多线程的几种方式：
>
> 1. 继承 Thread 类
> 2. 实现 Runnable 接口
> 3. 实现 Callable 接口
> 4. 线程池

三种方式的对比：

|                            | 优点                                         | 缺点                                       |
| -------------------------- | -------------------------------------------- | ------------------------------------------ |
| 实现Runnable、Callable接口 | 扩展性强，实现该接口的同时还可以继承其他的类 | 编程相对复杂，不能直接使用Thread类中的方法 |
| 继承Thread类               | 编程比较简单，可以直接使用Thread类中的方法   | 可扩展性较差，不能再继承其他的类           |

> 多线程：
>
> - 多线程是指从软件或者硬件上实现多个线程并发执行的技术
>
> - 具有多线程能力的计算机因有硬件支持而能够在同一时间执行多个线程，提升性能
>
> 并发和并行：
>
> - 并行：在同一时刻，有多个指令在多个CPU上同时执行
> - 并发：在同一时刻，有多个指令在单个CPU上交替执行
>
> 进程和线程：
>
> - 进程：就是操作系统中正在运行的一个应用程序
>   - 独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位
>   - 动态性：进程的实质是程序的一次执行过程，进程是动态产生，动态消亡的
>   - 并发性：任何进程都可以和其他进程一起并发执行
> - 线程：是进程中的单个顺序控制流，是一条执行路径
>   - 单线程：一个进程如果只有一条执行路径，则称为单线程程序
>   - 多线程：一个进程如果有多条执行语句，则称为多线程程序

## 一、继承 Thread 类

通过继承 Thread 类实现多线程的步骤如下：

1. 创建 MyThread 类，让其继承 Thread 类并重写 run() 方法。

2. 创建 MyThread 类的实例对象，即创建一个新线程。

3. 调用 start() 方法，启动线程。

```java
public class MyThread extends Thread {
    @Override
    public void run() {
        System.out.println("我是通过继承 Thread 类创建的多线程，我叫" + Thread.currentThread().getName());
    }
}

class TestMyThread {
    public static void main(String[] args) {
        MyThread myThread1 = new MyThread();
        myThread1.setName("Thread-1");
        MyThread myThread2 = new MyThread();
        myThread2.setName("Thread-2");
        MyThread myThread3 = new MyThread();
        myThread3.setName("Thread-3");

        myThread1.start();
        myThread2.start();
        myThread3.start();
    }
}
//run()方法和start()方法的区别？
//run()：封装线程执行的代码，直接调用，相当于普遍方法的调用，并没有开启线程
//start()：启动线程，然后由JVM调用此线程的run()方法
```

为了演示线程执行顺序的随机性，我特意创建了三个线程，并为每一个线程命名，下面是我运行3次程序的执行结果：

```java
// 第一次
我是通过继承 Thread 类创建的多线程，我叫Thread-2
我是通过继承 Thread 类创建的多线程，我叫Thread-1
我是通过继承 Thread 类创建的多线程，我叫Thread-3

// 第二次
我是通过继承 Thread 类创建的多线程，我叫Thread-1
我是通过继承 Thread 类创建的多线程，我叫Thread-3
我是通过继承 Thread 类创建的多线程，我叫Thread-2

// 第三次
我是通过继承 Thread 类创建的多线程，我叫Thread-1
我是通过继承 Thread 类创建的多线程，我叫Thread-3
我是通过继承 Thread 类创建的多线程，我叫Thread-2
```

从上面的执行结果我们可以看到**线程的执行顺序和代码中编写的顺序没有关系，线程的执行顺序是具有随机性的。**

## 二、实现 Runnable 接口

Runnable 接口只有一个 run() 方法，源码如下：

```java
public interface Runnable {
    public abstract void run();
}

```

通过实现 Runnable 接口实现多线程的步骤如下：

1. 创建 MyRunnable 类实现 Runnable 接口。

2. 创建 MyRunnable 类的实例对象 myRunnable 。

3. 把实例对象 myRunnable 作为参数来创建 Thread 类的实例对象 thread，实例对象 thread 就是一个新线程。

4. 调用 start() 方法，启动线程。

代码示例如下：

```java
public class MyRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println("我是通过实现 Runnable 接口创建的多线程，我叫" + Thread.currentThread().getName());
    }
}

class TestMyRunnable {
    public static void main(String[] args) {
        MyRunnable myRunnable = new MyRunnable();
        Thread thread = new Thread(myRunnable);
        thread.start();
    }
}
```

执行结果如下：

```
我是通过实现 Runnable 接口创建的多线程，我叫Thread-0
```

相比于继承 Thread 类的方法来说，实现 Runnable 接口是一个更好地选择，因为 Java 不支持多继承，但是可以实现多个接口。

有一点值得注意的是 Thread 类也实现了 Runnable 接口，这意味着构造函数 Thread(Runnable target) 不仅可以传入 Runnable 接口的对象，而且可以传入一个 Thread 类的对象，这样就可以将一个 Thread 对象中的 run() 方法交由其他线程进行调用。

## 三、实现 Callable 接口

Callable 接口只有一个 call() 方法，源码如下：

```java
public interface Callable<V> {
    V call() throws Exception;
}
```

从源码我们可以看到 Callable 接口和 Runnable 接口类似，它们之间的区别在于 run() 方法没有返回值，而 call() 方法是有返回值的。

通过实现 Callable 接口实现多线程的步骤如下：

1. 创建 MyCallable 类实现 Callable 接口。

2. 创建 MyCallable 类的实例对象 myCallable。

3. 把实例对象 myCallable 作为参数来创建 FutureTask 类的实例对象 futureTask。

4. 把实例对象 futureTask 作为参数来创建 Thread 类的实例对象 thread，实例对象 thread 就是一个新线程。

5. 调用 start() 方法，启动线程。

代码示例如下：

```java
public class MyCallable implements Callable<Integer> {
    @Override
    public Integer call() throws Exception {
        int a = 6;
        int b = 9;
        System.out.println("我是通过实现 Callable 接口创建的多线程，我叫" + Thread.currentThread().getName());
        return a + b;
    }
}

class TestMyCallable {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        MyCallable myCallable = new MyCallable();
        FutureTask<Integer> futureTask = new FutureTask(myCallable);
        Thread thread = new Thread(futureTask);
        thread.start();
        System.out.println("返回值为：" + futureTask.get());
    }
}
```

执行结果如下：

```java
我是通过实现 Callable 接口创建的多线程，我叫Thread-0
返回值为：15
```

FutureTask 类提供了一个 get() 方法用来获取 call() 方法的返回值，但需要注意的是调用这个方法会导致程序阻塞，必须要等到线程结束后才会得到返回值。

## 四、线程池

Java通过Executors创建线程池，分别为：

### 4.1 Executors.newCachedThreadPool()

创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程, 适用于服务器负载较轻，执行很多短期异步任务

```java
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue<Runnable>());
}
```

### 4.2 Executors.newFixedThreadPool(3)

创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待,适用于可以预测线程数量的业务中，或者服务器负载较重，对当前线程数量进行限制。

```java
public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue<Runnable>());
}
```

### 4.3 Executors.newScheduledThreadPool(3)

创建一个定长线程池，支持定时及周期性任务执行，适用于需要多个后台线程执行周期任务的场景。

```java
public ScheduledThreadPoolExecutor(int corePoolSize) {
    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,
          new DelayedWorkQueue());
}
```

### 4.4 newSingleThreadExecutor()

创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行，适用于需要保证顺序执行各个任务，并且在任意时间点，不会有多个线程时活动的场景。

```java
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>()));
}
```

### 4.5 Executors.newWorkStealingPool()

创建一个拥有多个任务队列的线程池，可以减少连接数，创建当前可用cpu数量的线程来并行执行，适用于大耗时的操作，可以并行来执行

```java
public static ExecutorService newWorkStealingPool() {
    return new ForkJoinPool
        (Runtime.getRuntime().availableProcessors(),
         ForkJoinPool.defaultForkJoinWorkerThreadFactory,
         null, true);
}
```

## 五、线程类的常见方法

### 5.1 获取线程的名称

- `String getName()`：返回此线程的名称
- 如果不设置名称，默认Thread-数字

### 5.2 设置线程的名字

- `void setName(String name)`：将此线程的名称更改为等于参数name
- 通过构造方法也可以设置线程名称

### 5.3 获得当前线程对象

- `public static Thread currentThread()`：返回对当前正在执行的线程对象的引用

### 5.4 线程休眠

- `public static void sleep(long time)`：让线程休眠指定的时间，单位为毫秒

## 六、线程调度

### 6.1 多线程的并发运行

- 计算机中的CPU，在任意时刻只能执行一条机器指令。每个线程只有获得CPU的使用权才能执行代码。

> 各个线程轮流获得CPU的使用权，分别执行各自的任务。

### 6.2 线程有两种调度模型

- 分时调度模型：所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间片
- 抢占式调度模型：优先让优先级高的线程使用CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的CPU时间片相对多一些

> Java采用的是抢占式调度模型

### 6.3 线程的优先级

- `public final void setPriority(int Priority)`：设置线程的优先级,默认优先级为5,范围为[1,10]
- `public final int getPriority()`：获取线程的优先级

### 6.4 后台线程/守护线程

- `public final void setDaemon(boolean on)`：设置为守护线程
- 当主要线程执行完毕之后，守护线程也没有继续执行下去的必要了，但守护线程不会在主线程执行完毕后立即停止，因为他还占有着CPU的 使用权，还会再执行一会。