---
title: 03.MySQL面试题
date: 2022-04-19 11:20:00
permalink: /interview/71f871
categories: 
  - 面试题
tags: 
  - 
---

## 2 MySQL InnoDB和MyISAM两大引擎对比？

- InnoDB存储引擎：从MySQL5.5版本之后，MySQL的默认内置存储引擎已经是InnoDB了，他的主要特点有：
  - InnoDB是MySQL5.5之后默认的数据库存储引擎，支持事务，支持外键
    - 使用共享表空间存储：所有的表和索引存放在同一个表空间中。
    - 使用多表空间存储：表结构放在frm文件，数据和索引放在IBD文件中。分区表的话，每个分区对应单独的IBD文件，分区表的定义可以查看我的其他文章。使用分区表的好处在于提升查询效率。
  - 灾难恢复性比较好；
  - 支持事务。默认的事务隔离级别为可重复度，通过MVCC（并发版本控制）来实现的。
  - 使用的锁粒度为行级锁，可以支持更高的并发；
  - 支持外键；
  - 配合一些热备工具可以支持在线热备份，有很成熟的在线热备解决方案；
  - 在InnoDB中存在着缓冲管理，通过缓冲池，将索引和数据全部缓存起来，加快查询的速度；
  - 对于InnoDB类型的表，其数据的物理组织形式是聚簇表。所有的数据按照主键来组织。数据和索引放在一块，都位于B+数的叶子节点上；
- MyISAM存储引擎：在5.5版本之前，MyISAM是MySQL的默认存储引擎，该存储引擎并发性差，不支持事务，所以使用场景比较少，主要特点为：
  - MyISAM是MySQL5.5之前的默认存储引擎，MyISAM既不支持事务，也不支持外键
    - 每个MyISAM在磁盘上存储成3个文件索引的结构是B+树结构其文件名都和表名相同，但拓展名分别是 ：
      - frm文件：存储表的定义数据,可以存放在不同的目录,平均分布IO，获得更快的速度
      - MYD文件：存放表具体记录的数据,可以存放在不同的目录,平均分布IO，获得更快的速度
      - MYI文件：存储索引,仅保存记录所在页的指针
    - 通过MYI的B+树结构来查找记录页，再根据记录页查找记录。并且支持全文索引、B树索引和数据压缩,支持数据的类型有以下三种
      - 静态固定长度表
      - 动态可变长表
      - 压缩表
  - 不支持事务；
  - 不支持外键，如果强行增加外键，不会提示错误，只是外键不其作用；
  - 对数据的查询缓存只会缓存索引，不会像InnoDB一样缓存数据，而且是利用操作系统本身的缓存；
  - 默认的锁粒度为表级锁，所以并发度很差，加锁快，锁冲突较少，所以不太容易发生死锁；
  - 支持全文索引（MySQL5.6之后，InnoDB存储引擎也对全文索引做了支持），但是MySQL的全文索引基本不会使用，对于全文索引，现在有其他成熟的解决方案，比如：ElasticSearch，Solr，Sphinx等。
  - 数据库所在主机如果宕机，MyISAM的数据文件容易损坏，而且难恢复；
- 查询性能上，MyISAM的查询效率高于InnoDB，因为InnoDB在查询过程中，是需要维护数据缓存，而且查询过程是先定位到行所在的数据块，然后在从数据块中定位到要查找的行；而MyISAM可以直接定位到数据所在的内存地址，可以直接找到数据；
- SELECT COUNT(\*)语句，如果行数在千万级别以上，MyISAM可以快速查出，而InnoDB查询的特别慢，因为MyISAM将行数单独存储了，而InnoDB需要朱行去统计行数；所以如果使用InnoDB，而且需要查询行数，则需要对行数进行特殊处理，如：离线查询并缓存；



InnoDB和MyISAM这两种引擎底层都是采用B+树的数据结构来构建索引。

B+树是B树的变种，B树是一棵多路平衡查找树，简单来说，B树可以看做平衡二叉树的进阶版，它与平衡二叉树的不同点主要在B树的一个节点可以存放多个关键字，并且B树的每个节点可以有两个以上的子节点，而这些都取决于B树的阶数，当B树的阶数为2时，它就是一个普通的平衡二叉树。单纯从数据结构来讲，B树和平衡二叉树在查找的时间复杂度上并没有什么区别，但数据结构比平衡二叉树复杂一些，计算机读取数据的操作中最耗时的是从磁盘中读取数据，在大多数linux系统中，每次磁盘io会取出4k的连续数据；平衡二叉树因为每个关键字都存放在独立的节点，无法保证在磁盘中的物理存储地址是连续的，因此，在最坏的情况下，每个关键字的读取都需要进行一次磁盘IO。而B树的每个节点可以存放多个关键字，每个节点的关键字在磁盘中的物理存储地址都是连续的，使得每次磁盘IO都可以读取多个关键字，大大减少了磁盘IO次数，使得查找时间更快。我们描述一棵B树是需要定义它的阶数，阶数定义了它最多会有多少个子节点。下面是一棵3阶的B树示例图，一棵m阶的B树简单定义如下：

- 每个节点最多可以有m个子节点
- 每个节点最多可以存放m-1个关键字

![image-20211025153854021](http://www.itxiaoshen.com:3001/assets/1635147532009ZCskpimw.png)

B+树是B树的变种，在B+树中，所有的关键字都会保存在叶子节点中，叶子节点之间也会有指针进行连接，形成一个链表的形式，和B树相比，这样的结构方便范围查找。比如要查询大于3的关键字，我们从根节点往下遍历，找到关键字为3的叶子节点之后，直接读取3之后的叶子节点就可以了，而不用一次次的从根节点去遍历大于3的关键字。当我们进行的范围查找进行倒序操作的时候，凭借叶子节点的单向链表是无法实现的，因此MySQL中的B+树结构做了一些调整，MySQL将B+树叶子节点的单向链表改为双向链表。而相同节点的B+树则如下，红色的箭头线是MySQL特殊改造实现的。

![image-20211025155643394](http://www.itxiaoshen.com:3001/assets/1635148601245Hxe4ByiS.png)

B+降低树的高度又能支持范围索引，MySQL在使用Innodb引擎的时候页大小默认是16K，一个三层B+树如果以十几个字节作为一个索引节点，叶子节点为800字节，那么也可存储两千万级别数据（1024\*1024\*20）

![image-20211025160355489](http://www.itxiaoshen.com:3001/assets/1635149069989wSfa1AcR.png)

基于B+为底层实现，我们也明白MySQL Innodb为何推荐使用自增ID作为主键，不要使用UUID这种作为主键，因为如果是自增主键增加节点就能顺序依次追加到后面即可，避免B+的结构出现分裂带来性能开销，在InnoDB存储引擎中，主键索引是作为聚簇索引存在的,也就是说,主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序),如果主键索引是自增ID,那么只需要不断向后排列即可,如果是UUID,由于到来的ID与原来的大小不确定,会造成非常多的数据插入,数据移动,然后导致产生很多的内存碎片,进而造成插入性能的下降.总之,在数据量大- -些的情况下,用自增主键性能会好一-些。

## 3 Hash索引和B+树所有有什么区别？

索引是一种数据结构,可以帮助我们快速的进行数据的查找。索引的数据结构和具体存储引擎的实现有关,在MySQL中使用较多的索引有B+树、Hash索引。Hash索引和B+树相比如下：

- hash索引底层就是hash表,进行查找时,调用一次hash函数就可以获取到相应的键值,之后进行回表查询获得实际数据.B+树底层实现是多路平衡查找树.对于每一次的查询都是 从根节点出发,查找到叶子节点方可以获得所查键值然后根据查询判断是否需要回表查询数据.
- hash索引进行等值查询更快(-般情况下),但是却无法进行范围查询.因为在hash索引中经过hash函数建立索引之后,索引的顺序与原顺序无法保持-致,不能支持 范围查询.而B+树的的所有节点皆遵循(左节点小于父节点,右节点大于父节点多叉树也类似,天然支持范围.
- hash索引不支持使用索引进行排序,原理同上.
- hash索引不支持模糊查询以及多列索引的最左前缀匹配.原理也是因为hash函数的不可预测AAAA和AAAB的索引没有相关性.
- hash索 引任何时候都避免不了回表查询数据,而B+树在符合某些条件(聚簇索引,覆盖索引等)的时候可以只通过索引完成查询.
- hash索引虽然在等 值查询上较快,但是不稳定.性能不可预测,当某个键值存在大量重复的时候发生hash碰撞,此时效率可能极差.而B+树的查询效率比较稳定

## 4 如何选择合适的存储引擎？

![image-20211025154214233](http://www.itxiaoshen.com:3001/assets/1635147734829sfKQc0rN.png)

- 使用场景是否需要事务支持；是否需要支持高并发，InnoDB的并发度远高于MyISAM；是否需要支持外键；是否需要支持在线热备；
- 高效缓冲数据，InnoDB对数据和索引都做了缓冲，而MyISAM只缓冲了索引；
- 索引，不同存储引擎的索引并不太一样；在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。以下是几种常用的存储引擎的使用环境。
  - InnoDB : 是Mysql的默认存储引擎，用于事务处理应用程序，支持外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询意外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。InnoDB存储引擎除了有效的降低由于删除和更新导致的锁定， 还可以确保事务的完整提交和回滚，对于类似于计费系统或者财务系统等对数据准确性要求比较高的系统，InnoDB是最合适的选择。
  - MyISAM ： 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。
  - MEMORY：将所有数据保存在RAM中，在需要快速定位记录和其他类似数据环境下，可以提供几块的访问。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，其次是要确保表的数据可以恢复，数据库异常终止后表中的数据是可以恢复的。MEMORY表通常用于更新不太频繁的小表，用以快速得到访问结果。
  - MERGE：用于将一系列等同的MyISAM表以逻辑方式组合在一起，并作为一个对象引用他们。MERGE表的优点在于可以突破对单个MyISAM表的大小限制，并且通过将不同的表分布在多个磁盘上，可以有效的改善MERGE表的访问效率。这对于存储诸如数据仓储等VLDB环境十分合适。

## 5 什么是聚簇索引和非聚簇索引？

在B+树的索引中,叶子节点可能存储了当前的key值,也可能存储了当前的key值以及整行的数据,这就是聚簇索引和非聚簇索引.在InnoDB中,只有主键索引是聚簇索引,如果没有主键,则挑选一个唯一键建立聚簇索引.如果没有唯一键，则隐式的生成一个键来建立聚簇索引.

当查询使用聚簇索引时,在对应的叶子节点,可以获取到整行数据,因此不用再次进行回表查询.

非聚簇索引一定会回表询吗?
不一定,这涉及到查询语句所要求的字段是否全部命中了索引,如果全部命中了索引,，那么就不必再进行回表查询.

举个简单的例子,假设我们在员工表的年龄上建立了索引,那么当进行select age from employee where age < 20的查询时,在索引的叶子节点上,已经包含了age信息,不会再次进行回表查询.

## 6 说说MySQL的联合索引？

MySQL可以使用多个字段同时建立一个索引,叫做联合索引.在联合索引中,如果想要 命中索引,需要按照建立索引时的字段顺序挨个使用，否则无法命中索引.MySQL联合索引底层数据结构也还是B+树，遵循索引最左前缀原则，单列索引其实也可以看做索引列为1的联合索引，联合索引的底层存储跟单列索引时类似的，联合索引是每个树节点中包含多个索引值，在通过索引查找记录时，会先将联合索引中第一个索引列与节点中第一个索引值进行匹配，匹配成功接着匹配第二个索引列和索引值，直到联合索引的所有索引列都匹配完；如果过程中出现某一个索引列与节点相应位置的索引值不匹配的情况，则无需再匹配节点中剩余索引列。

![image-20211025170426533](http://www.itxiaoshen.com:3001/assets/1635152671176S3ZitGrW.png)

比如：索引包含表中每一行的last_name、first_name和dob列，即key(last_name, first_name, dob)，以下情况可以用到索引：

- 匹配全值：对索引中的所有列都指定具体的值。
- 匹配最左前缀：你可以利用索引查找last name为Allen的人，仅仅使用索引中的第1列。
- 匹配列前缀：你可以利用索引查找last name以J开始的人，这仅仅使用索引中的第1列。
- 匹配值的范围查询：可以利用索引查找last name在Allen和Barrymore之间的人，仅仅使用索引中第1列。
- 匹配部分精确而其它部分进行范围匹配：可以利用索引查找last name为Allen，而first name以字母K开始的人。
- 仅对索引进行查询：如果查询的列都位于索引中，则不需要读取元组的值。

## 7 MySQL的binlog有几种格式?

MySQL的binlog有三种格式,分别是statement、row、mixed。

- statement模式下，记录单元为语句.即每- 个sql造成的影响会记录.由于sql的执行是有上下文的,因此在保存的时候需要保存相关的信息,同时还有一-些使用了函数之类的语句无法被记录复制。
- row级别下,记录单元为每一-行的改动,基本是可以全部记下来但是由于很多操作,会导致大量行的改动(比如alter table),因此这种模式的文件保存的信息太多，日志量太大。
- mixed. -种折中的方案,普通操作使用statement记录,当无法使用statement的时候使用row.此外,新版的MySQL中对row级别也做了- -些优化，当表结构发生变化的时候，会记录语句而不是逐行记录。

## 8 MySQL如何做调优？

- 核心理念
  - 选择合适的存储引擎
  - 平衡范式与冗余，为提高效率可以牺牲范式设计，冗余数据。
  - 最大化利用索引，尽可能避免全表扫描，减少无效数据的查询；
  - 不在数据库做计算，cpu计算务必移至业务层。
  - 控制单表数据量，单表记录控制在千万级。控制列数量，字段数控制在20以内。
  - 拒绝3B(big)，也即是大sql，大事务，大批量。
- 基本原则
  - 减少数据访问：设置合理的字段类型，启用压缩，通过索引访问等减少磁盘IO；
  - 返回更少的数据：只返回需要的字段和数据分页处理 减少磁盘io及网络io；
  - 减少交互次数：批量DML操作，函数存储等减少数据连接次数；
  - 减少服务器CPU开销：尽量减少数据库排序操作以及全表查询，减少cpu 内存占用；
  - 利用更多资源：使用表分区，可以增加并行操作，更大限度利用cpu资源
- 字段类优化
  - 用好数值类型：
    - tinyint(1Byte)/smallint(2Byte)/mediumint(3Byte)/int(4Byte)/bigint(8Byte) bad case：int(1)/int(11)
    - 有些字符转化为数字|：用int而不是char(15)存储ip
    - 优先使用enum或set，例如：sex enum (‘F’, ‘M’)
  - 避免使用NULL字段：
    - NULL字段很难查询优化
    - NULL字段的索引需要额外空间
    - NULL字段的复合索引无效
- 索引原则
  - 选择唯一性索引，唯一性索引的值是唯一的，可以更快速的通过该索引来确定某条记录。
  - 为经常需要排序、分组和联合操作的字段建立索引。
  - 为常用作为查询条件的字段建立索引。
  - 限制索引的数目：越多的索引，会使更新表变得很浪费时间。尽量使用数据量少的索引，如果索引的值很长，那么查询的速度会受到影响。尽量使用前缀来索引，如果索引字段的值很长，最好使用值的前缀来索引。
  - 删除不再使用或者很少使用的索引。
  - 最左前缀匹配原则，非常重要的原则。
  - 尽量选择区分度高的列作为索引区分度的公式是表示字段不重复的比例。
  - 索引列不能参与计算，保持列“干净”：带函数的查询不参与索引。
  - 尽量的扩展索引，不要新建索引
- 索引类优化，例如：
  - 谨慎合理使用索引
  - 改善查询、减慢更新
  - 索引一定不是越多越好（能不加就不加，要加的一定得加）
  - 覆盖记录条数过多不适合建索引，例如“性别”
  - 字符字段必须建前缀索引
  - 不在索引做列运算
  - innodb主键合理使用自增列，主键建立聚簇索引，主键不应该被修改，字符串不应该做主键，如果不指定主键，innodb会使用唯一且非空值索引代替
  - 不用外键，请由程序保证约束
- sql类优化如，例如：
  - sql语句尽可能简单
  - 一条sql只能在一个cpu运算
  - 大语句拆小语句，减少锁时间
  - 一条大sql可以堵死整个库
  - 简单的事务
  - 事务时间尽可能短
- 调优方法
  - 通过慢查询找到sql语句
  - MySQL提供了explain命令来查看语句的执行计划,MySQL在执行某个语句之前,会将该语句过一-遍查询优化器,之后会拿到对语句的分析,也就是执行计划，其中包含了许多信息.
  - 可以通过其中和索引有关的信息来分析是否命中了索引,例如，possilbe_ key,key,key_ len等字段,分别说明了此语句可能会使用的索引,实际使用的索引以及使用的索引长度

## 9 MySQL如何应对数据量快速增大？

- 读写分离（适合读请求较多，写请求较少场景）
  - Mycat 代理层方案
  - Apache ShardingSphere 
- 分库分表
  - Mycat 代理层方案
  - Apache ShardingSphere
- NewSql数据库（新一代分布式关系型数据库解决方案）
  - TiDB

## 10 如何设计数据库？

- 需求分析阶段：梳理出数据流程图DFD
- 概念设计阶段：抽象出具体DBMS的模型E-R图、概念数据模型、逻辑数据模型、物理数据模型
- 数据库设计三范式、外键的考虑
- 逻辑设计阶段：外键、索引、视图，数据库选型：数据存储、检索、安全、读写分离、分库分表、数据归档、接入数据仓库
- 物理设计阶段：存储过程、触发器、用户自定义函数、表空间

## 11 MySQL同时有多个事务可能会产生什么问题？

多事务的并发进行一般会造成以下几个问题

- 脏读: A事务读取到了B事务未提交的内容,而B事务后面进行了回滚.
- 不可重复读:当设置A事务只能读取B事务已经提交的部分，会造成在A事务内的两次查询,结果竟然不-样,因为在此期间B事务进行了提交操作.
- 幻读: A事务读取了一一个范围的内容,而同时B事务在此期间插入了-条数据造成”幻觉"

## 12 说说MySQL事务隔离级别?

MySQL和其他关系型数据库一样有四种隔离级别，InnoDB默认使用的是可重复读隔离级别，四种隔离级别如下:

- 未提交读(READ UNCOMMITTED)
  - 这就是.上面所说的例外情况了,这个隔离级别下，其他事务可以看到本事务没有提交的部分修改因此会造成脏读的问题(读取到了其他事务未提交的部分,而之后该事务进行了回滚).这个级别的性能没有足够大的优势,但是又有很多的问题,因此很少使用.
- 已提交读(READ COMMITTED)
  - 其他事务只能读取到本事务已经提交的部分.这个隔离级别有不可重复读的问题,在同-一个事务内的两次读取,拿到的结果竟然不一样,因为另外- -个事务对数据进行了修改.
- REPEATABLE READ(可重复读)
  - 可重复读隔离级别解决了上面不可重复读的问题(看名字也知道),但是仍然有-个新问题,就是幻读,当你读取id> 10的数据行时,对涉及到的所有行加上了读锁,此时例外一个事务新插入了-条id=11的数据,因为是新插入的,所以不会触发上面的锁的排斥,那么进行本事务进行下一次的查询时会发现有一条id=11的数据,而 上次的查询操作并没有获取到,再进行插入就会有主键冲突的问题.
- SERIALIZABLE(可串行化)
  - 这是最高的隔离级别,可以解决上面提到的所有问题,因为他强制将所以的操作串行执行,这会导致并发性能极速下降,因此也不是很常用.

## 13 说说对于MySQL锁的理解

![image-20211025182128987](http://www.itxiaoshen.com:3001/assets/1635157295139kdT6CSJ1.png)

- 从锁的类别上来讲,有共享锁和排他锁
  - 共享锁:又叫做读锁.可以通过lock in share mode实现，这时候只能读不能写，当用户要进行数据的读取时，对数据加上共享锁共享锁可以同时加上多个。
    - select \* from t_logs where id = 1 lock in share mode 相当于上了读锁（共享锁）
  - 排他锁:又叫做写锁.它会阻塞其他的写锁和读锁。从颗粒度来区分，可以分为表锁和行锁、页锁。当用户要进行数据的写入时,对数据加上排他锁排他锁只可以加一-个 ,他和其他的排他锁,共享锁都相斥。
    - select \* from t_logs where id = 1 for update 其中增删改操作自动上行锁，相当于上了写锁（排它锁）
  - 锁的粒度取决于具体的存储引擎,InnoDB实现了行级锁,页级锁,表级锁.他们的加锁开销从大大小,并发能力也是从大到小。
  - 表锁会锁定整张表并且阻塞其他用户对该表的所有读写操作，比如alter修改表结构的时候会锁表。
  - 行锁又可以分为乐观锁和悲观锁，悲观锁可以通过for update实现，乐观锁则通过版本号实现。
  - 间隙锁是可重复读级别下才会有的锁，MVCC(多版本并发控制，实际上就是保存了数据在某个时间节点的快照）和间隙锁,、mvcc+next-key锁、记录锁或者行锁+间隙锁）来解决幻读的问题,。
- 锁的处理机制分为乐观锁和悲观锁
  - 加锁时机
    - 悲观锁，从数据开始修改时就将数据锁住，直到更改完成才释放锁。
    - 乐观锁，直到数据修改完准备提交时才上锁，完成后释放。
  - 并发性
    - 因为悲观锁是在事务执行中加锁，当并发量高时，就有可能会对其他事务进程造成影响，造成其他事务进程执行时间过程，导致事务超时。
    - 乐观锁是在对数据进行检查时才加锁，锁的时间会少很多，而只有锁住数据的时候会影响其它事务。
  - 两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。
- 活锁：使用优先级队列，先来一直获取不到锁。
- 死锁：一次性封锁法、顺序封锁法，事先规定顺序。
- mysql锁分为共享锁和排他锁，也叫做读锁和写锁。读锁是共享的，可以通过lock in share mode实现，这时候只能读不能写。写锁是排他的，它会阻塞其他的写锁和读锁。从颗粒度来区分，可以分为表锁和行锁两种。表锁会锁定整张表并且阻塞其他用户对该表的所有读写操作，比如alter修改表结构的时候会锁表。行锁又可以分为乐观锁和悲观锁，悲观锁可以通过for update实现，乐观锁则通过版本号实现。间隙锁是可重复读级别下才会有的锁，结合MVCC和间隙锁可以解决幻读的问题。

## 14 mysql怎么实现可重复读？

mysql可重复读主要通过undo log版本链+ReadView 机制实现，具体如下

![image-20211025182600753](http://www.itxiaoshen.com:3001/assets/1635157567082CKtTKeHR.png)

当 MySQL 执行写操作之前，会把即将被修改的数据记录到 undo log 日志里面。只有这样，事务要回滚的时候，即使 Buffer Pool 中的数据被修改了，依然可以从 undo log 日志中，读取到原插入、修改、删除之前的值，最终把值重新变回去，这就是回滚操作。

![image-20211025182633274](http://www.itxiaoshen.com:3001/assets/1635157595672A6MSmB8R.png)

日志与日志之间通过 roll_pointer 指针连接，就形成了 undo log 版本链。基于 undo log 版本链实现的 ReadView 机制：ReadView 说白了就是一种数据结构，它主要包含这样几部分：

- m_ids，当前有哪些事务正在执行，且还没有提交，这些事务的 id 就会存在这里；
- min_trx_id，是指 m_ids 里最小的值；
- max_trx_id，是指下一个要生成的事务 id。下一个要生成的事务 id 肯定比现在所有事务的 id 都大；
- creator_trx_id，每开启一个事务都会生成一个 ReadView，而 creator_trx_id 就是这个开启的事务的 id。

## 15 ACID是什么？

事务是一系列的操作,他们要符合ACID特性.最常见的理解就是:事务中的操作要么全部成功,要么全部失败。

- A=Atomicity，原子性,就是上面说的,要么全部成功,要么全部失败.不可能只执行一部分操作。
- C=Consistency，系统(数据库)总是从一个-致性的状态转移到另一 个一 致性的状态,不会存在中间状态。
- I=Isolation，隔离性:通常来说:一个事务在完全提交之前,对其他事务是不可见的.注意前面的通常来说加了红色，意味着有例外情况.
- D=Durability，持久性,一旦事务提交,那么就永远是这样子了,哪怕系统崩溃也不会影响到这个事务的结果

## 16 简单说说MySQL三大日志？

- binlog 用来保证可以将数据库状态恢复到任一时刻。
  - MySQL 整体来看，分为 Server 层和引擎层，而 binlog 是 Server 层面的 log 文件，也就是所有执行引擎都有 binlog。
- redo log ：用来保证 crash-safe，InnoDB可以保证即使数据库发生异常重启，之前提交的记录都不会丢失。
  - 分为prepare 和 commit两个步骤也即是“两阶段提交”。
  - 将操作先更新到内存，再写入 redo log，此时标记为 prepare 状态，再写入 binlog，此时再提交事务，将 redo log 标记为 commit 状态。
- undo log 是用来保证事务需要回滚时数据状态的回滚和 MVCC 时，记录各版本数据信息。
  - undo log 和 redo log 也是引擎层的 log 文件，undo log 提供了回滚和多个行版本控制（MVCC），在数据库修改操作时，不仅记录了 redo log，还记录了 undo log，如果因为某些原因导致事务执行失败回滚了，可以借助 undo log 进行回滚。

## 17 MySQL如何保证ACID？

- Mysql怎么保证一致性的？

  - 从数据库层面，数据库通过原子性、隔离性、持久性来保证一致性。也就是说ACID四大特性之中，C(一致性)是目的，A(原子性)、I(隔离性)、D(持久性)是手段，是为了保证一致性，数据库提供的手段。数据库必须要实现AID三大特性，才有可能实现一致性。例如，原子性无法保证，显然一致性也无法保证。但是，如果你在事务里故意写出违反约束的代码，一致性还是无法保证的。例如，你在转账的例子中，你的代码里故意不给B账户加钱，那一致性还是无法保证。因此，还必须从应用层角度考虑。
  - 从应用层面，通过代码判断数据库数据是否有效，然后决定回滚还是提交数据。

- Mysql怎么保证原子性的？

  - 利用Innodb的undo log。
    - undo log名为回滚日志，是实现原子性的关键，当事务回滚时能够撤销所有已经成功执行的sql语句，他需要记录你要回滚的相应日志信息。例如
      - 当你delete一条数据的时候，就需要记录这条数据的信息，回滚的时候，insert这条旧数据。
      - 当你update一条数据的时候，就需要记录之前的旧值，回滚的时候，根据旧值执行update操作。
      - 当年insert一条数据的时候，就需要这条记录的主键，回滚的时候，根据主键执行delete操作。
    - undo log记录了这些回滚需要的信息，当事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。

- Mysql怎么保证持久性的？

  - 利用Innodb的redo log。
    - 正如之前说的，Mysql是先把磁盘上的数据加载到内存中，在内存中对数据进行修改，再刷回磁盘上。如果此时突然宕机，内存中的数据就会丢失。
    - 那怎么解决上面这个问题，简单啊，事务提交前直接把数据写入磁盘就行啊。这么做有什么问题？
    - 只修改一个页面里的一个字节，就要将整个页面刷入磁盘，太浪费资源了。毕竟一个页面16kb大小，你只改其中一点点东西，就要将16kb的内容刷入磁盘，听着也不合理。
    - 毕竟一个事务里的SQL可能牵涉到多个数据页的修改，而这些数据页可能不是相邻的，也就是属于随机IO。显然操作随机IO，速度会比较慢。
  - 于是决定采用redo log解决上面的问题。当做数据修改的时候，不仅在内存中操作，还会在redo log中记录这次操作。当事务提交的时候，会将redo log日志进行刷盘(redo log一部分在内存中，一部分在磁盘上)。当数据库宕机重启的时候，会将redo log中的内容恢复到数据库中，再根据undo log和binlog内容决定回滚数据还是提交数据。
  - 采用redo log的好处？
    - 其实好处就是将redo log进行刷盘比对数据页刷盘效率高，具体表现如下
    - redo log体积小，毕竟只记录了哪一页修改了啥，因此体积小，刷盘快。
    - redo log是一直往末尾进行追加，属于顺序IO。效率显然比随机IO来的快。

- Mysql怎么保证隔离性的？

  

  - 利用的是锁和MVCC机制。还是拿转账例子来说明，有一个账户表如下：
    - 设立利用索引，减少锁的竞争。
    - 调整sql执行顺序，让长时间持有事务操作放在前面。
    - 避免大的事务，尽量拆分为多个子事务。
    - 以固定顺序访问表和行。

## 18 MySQL如何尽可能避免死锁

- 以固定的顺序访问表和行。比如对第2节两个job批量更新的情形，简单方法是对id列表先排序，后执行，这样就避免了交叉等待锁的情形；又比如对于3.1节的情形，将两个事务的sql顺序调整为一致，也能避免死锁。
- 大事务拆小。大事务更倾向于死锁，如果业务允许，将大事务拆小。
- 在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁概率。
- 降低隔离级别。如果业务允许，将隔离级别调低也是较好的选择，比如将隔离级别从RR调整为RC，可以避免掉很多因为gap锁造成的死锁。
- 为表添加合理的索引。可以看到如果不走索引将会为表的每一行记录添加上锁，死锁的概率大大增大。
- Innodb提供了wait-for graph算法来主动进行死锁检测，Innodb目前处理死锁的方法就是将持有最少行级排他锁的事务进行回滚。这也是相对比较简单的死锁回滚方式。

## 19 MySQL主从复制有几种复制方式？

- 异步复制

  - MySQL主从异步复制是最常见的复制场景。数据的完整性依赖于主库BINLOG的不丢失，只要主库的BINLOG不丢失，那么就算主库宕机了，我们还可以通过BINLOG把丢失的部分数据通过手工同步到从库上去

- 多线程复制

  - 在MySQL5.7中，带来了全新的多线程复制技术，解决了当master同一个schema下的数据发生了变更，从库不能并发应用的问题，同时也真正将binlog组提交的优势充分发挥出来，保障了从库并发应用Relay Log的能力。
  - 在MySQL8.0中，多线程复制又进行了技术更新，引入了writeset的概念，而在之前的版本中，如果主库的同一个会话顺序执行多个不同相关对象的事务，例如，先执行了Update A表的数据，又执行了Update B表的数据，那么BINLOG在复制到从库后，这两个事务是不能并行执行的，writeset的到来，突破了这个限制。

- 增强半同步复制

  - 从MySQL5.5开始，引入了半同步复制，此时的技术暂且称之为传统的半同步复制，因该技术发展到MySQL5.7后，已经演变为增强半同步复制(也成为无损复制)。在异步复制时，主库执行Commit提交操作并写入BINLOG日志后即可成功返回客户端，无需等待BINLOG日志传送给从库。

  ![image-20211025234809060](http://www.itxiaoshen.com:3001/assets/1635176893007XCj0memZ.png)

- 阿里开源Mysql数据同步工具有Otter、Canal，默认从服务器订阅bin log同步协议，实现数据增量同步。

- 基于binlog主从复制原理和流程如下

![image-20211025233936755](http://www.itxiaoshen.com:3001/assets/1635176389666nyQ47NeM.png)

## 20 索引的分类

- 主键索引：PRIMARY KEY

- - 设定为逐渐后，数据库自动建立索引，innodb为聚簇索引，主键索引列值不能有空(Null)

- 单值索引：又叫单列索引、普通索引

- - 即，一个索引只包含单个列，一个表可以有多个单列索引

- 唯一索引

- - 索引列的值必须唯一，但允许有空值(Null)，但只允许有一个空值(Null)

- 复合索引

- - 即，一个索引可以包含多个列，多个列共同构成一个复合索引！
  - eg: `SELECT id (name age) INDEX WHERE name AND age;`

- 全文索引：Full Text  （MySQL5.7之前，只有MYISAM存储引擎支持全文索引）

- - 全文索引类型为FULLTEXT，在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值和空值。全文索引可以在**Char** 、**Varchar** 上创建。

## 21 什么是约束以及分类

约束:

- 作用：是为了**保证数据的完整性**而实现的摘自一套机制，即(约束是针对表中数据记录的)
- MySQL中的约束：

- - 非空约束：**NOT NULL**  保证某列数据不能存储NULL 值;
  - 唯一约束：**UNIQUE(字段名)**  保证所约束的字段，数据必须是唯一的，允许数据是空值(Null)，但只允许有一个空值(Null)；

- - 主键约束：**PRIMARY KEY(字段名)**  `主键约束= 非空约束 + 唯一约束` 保证某列数据不能为空且唯一；
  - 外键约束：**FOREIGN KEY(字段名)**  保证一个表中某个字段的数据匹配另一个表中的某个字段，可以建立表与表直接的联系；

- - 自增约束：**AUTO_INCREMENT**  保证表中新插入数据时，某个字段数据可以依次递增；
  - 默认约束：**DEFALUT** 保证表中新插入数据时，如果某个字段未被赋值，则会有默认初始化值；

- - 检查性约束：**CHECK** 保证列中的数据必须符合指定的条件；

## 22 索引哪些情况会失效

- 查询条件包含or，可能导致索引失效
- 如何字段类型是字符串，where时一定用引号括起来，否则索引失效

- like通配符可能导致索引失效。
- 联合索引，查询时的条件列不是联合索引中的第一个列，索引失效。

- 在索引列上使用mysql的内置函数，索引失效。
- 对索引列运算（如，+、-、*、/），索引失效。

- 索引字段上使用（！= 或者 < >，not in）时，可能会导致索引失效。
- 索引字段上使用is null， is not null，可能导致索引失效。

- 左连接查询或者右连接查询查询关联的字段编码格式不一样，可能导致索引失效。
- mysql估计使用全表扫描要比使用索引快,则不使用索引。

## 23 索引不适合哪些场景

- 数据量少的不适合加索引
- 更新比较频繁的也不适合加索引

- 区分度低的字段不适合加索引（如性别）

## 24 索引的一些潜规则

- 覆盖索引
- 回表

- 索引数据结构（B+树）
- 最左前缀原则

- 索引下推

## 25 MySQL 遇到过死锁问题吗，你是如何解决的？

1. 查看死锁日志show engine innodb status;
2. 找出死锁Sql

3. 分析sql加锁情况
4. 模拟死锁案发

5. 分析死锁日志
6. 分析死锁结果

## 26 日常工作中你是怎么优化SQL的？

1. 加索引
2. 避免返回不必要的数据

3. 适当分批量进行
4. 优化sql结构

5. 分库分表
6. 读写分离

## 27 分库分表方案:

- 水平分库：以字段为依据，按照一定策略（hash、range等），将一个库中的数据拆分到多个库中。
- 水平分表：以字段为依据，按照一定策略（hash、range等），将一个表中的数据拆分到多个表中。

- 垂直分库：以表为依据，按照业务归属不同，将不同的表拆分到不同的库中。
- 垂直分表：以字段为依据，按照字段的活跃性，将表中字段拆到不同的表（主表和扩展表）中。

## 28 常用的分库分表中间件：

- sharding-jdbc（当当）
- Mycat

- TDDL（淘宝）
- Oceanus(58同城数据库中间件)

- vitess（谷歌开发的数据库中间件）
- Atlas(Qihoo 360)

## 29 事务的隔离级别有哪些？MySQL的默认隔离级别是什么？

- 读未提交（Read Uncommitted）
- 读已提交（Read Committed）

- 可重复读（Repeatable Read）
- 串行化（Serializable）

Mysql默认的事务隔离级别是可重复读(Repeatable Read)

## 30 什么是幻读，脏读，不可重复读呢？

- 事务A、B交替执行，事务A被事务B干扰到了，因为事务A读取到事务B未提交的数据,这就是脏读
- 在一个事务范围内，两个相同的查询，读取同一条记录，却返回了不同的数据，这就是不可重复读。

- 事务A查询一个范围的结果集，另一个并发事务B往这个范围中插入/删除了数据，并静悄悄地提交，然后事务A再次查询相同的范围，两次读取得到的结果集不一样了，这就是幻读。

## 31 在高并发情况下，如何做到安全的修改同一行数据？

要安全的修改同一行数据，就要保证一个线程在修改时其它线程无法更新这行记录。一般有悲观锁和乐观锁两种方案~

### 31.1 使用悲观锁

悲观锁思想就是，当前线程要进来修改数据时，别的线程都得拒之门外~比如，可以使用select…for update ~select * from User where name=‘jay’ for update以上这条sql语句会锁定了User表中所有符合检索条件（name=‘jay’）的记录。本次事务提交之前，别的线程都无法修改这些记录。

### 31.2 使用乐观锁

乐观锁思想就是，有线程过来，先放过去修改，如果看到别的线程没修改过，就可以修改成功，如果别的线程修改过，就修改失败或者重试。实现方式：乐观锁一般会使用版本号机制或CAS算法实现。

## 32 MySQL事务得四大特性以及实现原理

- 原子性： 事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。
- 一致性： 指在事务开始之前和事务结束以后，数据不会被破坏，假如A账户给B账户转10块钱，不管成功与否，A和B的总金额是不变的。

- 隔离性： 多个事务并发访问时，事务之间是相互隔离的，即一个事务不影响其它事务运行效果。简言之，就是事务之间是进水不犯河水的。
- 持久性： 表示事务完成以后，该事务对数据库所作的操作更改，将持久地保存在数据库之中。

### 32.1 事务ACID特性的实现思想

- 原子性：是使用 undo log来实现的，如果事务执行过程中出错或者用户执行了rollback，系统通过undo log日志返回事务开始的状态。
- 持久性：使用 redo log来实现，只要redo log日志持久化了，当系统崩溃，即可通过redo log把数据恢复。

- 隔离性：通过锁以及MVCC,使事务相互隔离开。
- 一致性：通过回滚、恢复，以及并发情况下的隔离性，从而实现一致性。

## 33 Mysql中有哪几种锁，列举一下？

如果按锁粒度划分，有以下3种：

- 表锁： 开销小，加锁快；锁定力度大，发生锁冲突概率高，并发度最低;不会出现死锁。
- 行锁： 开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高。

- 页锁： 开销和加锁速度介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般

## 34 Mysql的binlog有几种录入格式？分别有什么区别？

有三种格式哈，statement，row和mixed。

- statement，每一条会修改数据的sql都会记录在binlog中。不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。
- row，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多，日志量太大。

- mixed，一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。

## 35 B树和B+树的区别，数据库为什么使用B+树而不是B树？

- 在B树中，键和值即存放在内部节点又存放在叶子节点；在B+树中，内部节点只存键，叶子节点则同时存放键和值。
- B+树的叶子节点有一条链相连，而B树的叶子节点各自独立的。

- B+树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的，链表连着的。那么B+树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。.
- B+树非叶子节点上是不存储数据的，仅存储键值，而B树节点中不仅存储键值，也会存储数据。innodb中页的默认大小是16KB，如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的IO次数有会再次减少，数据查询的效率也会更快.